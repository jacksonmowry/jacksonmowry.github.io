# Start Here

`Name`: Jackson Mowry
`NetID`: jmowry4

For each problem below, you will,

1. Fill in the the flag
2. List the steps necessary to exploit the binary. *(May be a single line.)*
3. Provide a patch that fixes the exploit. *(Generated using `make diff`.)*
4. An explanation of what the vulnerability was and how the patch fixes it. *(Keep this explanation short and to the point.)*

---

## problem1

### Flag
`flag{366-iNt3G3r5iGNc0nV3r5i0N}`

### Exploit Steps
1. Enter an number larger than the max signed integer, causing an overflow.

### Patch
```diff
--- .originals/problem1.c       2023-03-03 22:16:49.000000000 +0000
+++ problem1.c  2025-03-04 10:35:50.921008689 +0000
@@ -37,14 +37,14 @@

 // Handle a large withdraw
 void large_withdraw(struct user_account *u) {
-  unsigned int withdrawal;
+  int withdrawal;

   printf("How much would you like to withdraw?\n> ");
-  scanf("%u", &withdrawal);
+  scanf("%d", &withdrawal);
   withdrawal += 50;

   // Ensure the user has enough money to complete the transaction
-  if (!check_withdraw_amount(withdrawal, u)) {
+  if (withdrawal < 0 || !check_withdraw_amount(withdrawal, u)) {
     printf("Sorry, you do not have enough funds to complete this withdrawal.\n");
     printf("Have a good day!\n");
     return;
```

### Explanation
The original code is scanning for an unsigned integer which is then cast to an integer when making the comparison, this causes an integer overflow during the truncation. If we change this to be a signed integer we will no longer have this issue.

---

## problem2

### Flag
flag{366-bUFF3r0v3RF10w_r3turn}

### Exploit Steps
1. Exploit a buffer overflow to overwrite the return address of `parrot`. Specifically writing out 44 bytes, then the desired return address (in little endian).

### Patch
```diff
--- .originals/problem2.c	2023-03-03 22:16:49.000000000 +0000
+++ problem2.c	2025-03-04 11:41:14.653507694 +0000
@@ -10,7 +10,7 @@
   char out[32];
 
   memset(out, 0, sizeof(out));
-  strcpy(out, input);
+  strncpy(out, input, sizeof(out) - 1);
 
   // Copy the user's input and print it out.
   printf("user:   %s\n", input);
@@ -34,3 +34,5 @@
   flag();
   printf("Success!\n");
 }
+
+// 08049280
```

### Explanation
`strcpy` is inherently vulnerable when copying user controlled buffers, this specific program performs no bounds checking so the entire users input is copied into a buffer that may be too small. By changing to `strncpy` we can effectively eliminate the threat of a buffer overflow.

---

## problem3

### Flag
flag{366-BufFeR0v3rf10W_C4n4ry}

### Exploit Steps
1. Fill the user password buffer with char `a`, then continue writing into the secret buffer filled with `b`. `a`+1 == b, so the password algorithm now passes.

### Patch
```diff
--- .originals/problem3.c	2023-03-03 22:16:49.000000000 +0000
+++ problem3.c	2025-03-04 11:48:08.661330003 +0000
@@ -11,12 +11,12 @@
 bool checkPassword(char *input) {
   char passwordBuffer[16];
   char secret[16];
- 
+
   // Set the secret value. Hidden from prying eyes...
 
   // Check that the passwords match. We're using my super special comparison function that
   // shifts password characters over by 1... throws off the hackers!
-  strcpy(passwordBuffer, input);
+  strncpy(passwordBuffer, input, sizeof(passwordBuffer) - 1);
 
   for (size_t i = 0; i < sizeof(passwordBuffer); i++) {
     passwordBuffer[i]++;
```

### Explanation
Same as the last problem, we're copying user controlled content into a statically sized buffer without a bounds check. To mitigate a buffer overflow we use a compile time known size for `strncpy`. This was the attacker cannot write past the bounds of the array.

---

## problem4

### Flag
flag{366-iNt3g3r0v3rF10w}

### Exploit Steps
1. Figure out the what positive integer `-504` would be equal to by comparing their binary representation. Divide that number by 2 so that it fits within a signed integer, then enter both numbers to get `-504`.

### Patch
```diff
--- .originals/problem4.c	2023-03-03 22:16:49.000000000 +0000
+++ problem4.c	2025-03-04 12:08:29.620763421 +0000
@@ -33,11 +33,11 @@
 
   result = value * factor;
 
-  if (result == reset_key) {
+  if (result >= 0 && result == reset_key) {
     // reset_key is only usable by admins, normal users shouldn't worry about it...
     // Plus it's not like you can multiple 2 positive numbers to get a negative number anyway...
     flag();
   } else {
     printf("Product: %d\n", result);
   }
-}
\ No newline at end of file
+}
```

### Explanation
Even though we're only allowing signed integers for the 2 operands, they can still result in a negative number. This would be a caused by an integer overflow, where we go past the max int, into the negative numbers. We only expect positive results, so I added a check to ensure the result it positive before the flag/admin check.

---

## problem5

### Flag
flag{366-r5C3c0nd170n}

### Exploit Steps
1. Use bash to spawn the process, grab its PID, and then touch that file it will attempt to create. The program then gives us the key.

### Patch
```diff
--- .originals/problem5.c	2023-03-03 22:16:49.000000000 +0000
+++ problem5.c	2025-03-04 12:22:55.918337711 +0000
@@ -19,7 +19,7 @@
 
     // Ok, let's open this file and write the flag to it.
     // Haha... just kidding, the user doesn't have access to the file, so this call will fail.
-    FILE *outFile = fopen(destinationFile, "r");
+    FILE *outFile = fopen(destinationFile, "x");
     if (outFile == NULL) {
       printf("This is my file... I told you that you couldn't access it. Neener-neener!\n");
       // If the file did exist, we would write to it here.
@@ -30,4 +30,4 @@
       flag();
     }
   }
-}
\ No newline at end of file
+}
```

### Explanation
This is a time of check time of use exploit, which can easily be mitigated by enforcing that the file doesn't exist when we create it. The program is checking the condition, sleeping, and then not reverifying the condition before executing. This can be accomplished via the "x" flag when calling `fopen`. Open the file in exclusive mode, so that if it already exists we fail.

---

## problem6

### Flag
flag{366-1n73g3RUnd3rfl0W}

### Exploit Steps
1. Try guesses until the correct guess was found, if you enter junk when it asks you to quit you can keep playing.

```bash
for i in {a..z}; do for j in {a..z}; do for k in {a..z}; do printf '%c%c%c\n' $i $j $k; done; done; done | ./problem6
```

### Patch
```diff
--- .originals/problem6.c	2023-03-03 22:16:49.000000000 +0000
+++ problem6.c	2025-03-04 12:38:07.713530610 +0000
@@ -43,10 +43,7 @@
       }
     } else {
       printf("You've run out of guesses! Please quit by pressing 'q': ");
-      scanf("%1s", input);
-      if (strstr(input, "q")) {
-        break;
-      }
+      break;
     }
 
     --remainingGuesses;
```

### Explanation
The turns remaining value is not being correctly checked as it is unsigned (which is always > 0), so we just underflow it allowing us to continue playing. We're asking the user Instead of letting the user choose to quit we just break the program when they run out of guesses.

---

## problem7

### Flag
flag{366-Rac3c0ndi7i0N_2}

### Exploit Steps
1. Build up a significant account balance so that when the withdraw threads spawn they all check a very high value (TOCTOU). Then they start their decrement loops, which allows the number to move below the minimum account balance.

### Patch
```diff
--- .originals/problem7.c	2023-03-03 22:16:49.000000000 +0000
+++ problem7.c	2025-03-04 13:15:49.115587338 +0000
@@ -6,6 +6,7 @@
 #include <string.h>
 
 static const int MAX_BALANCE = 2000000000;
+pthread_mutex_t account_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 int accountBalance = 1000;
 
@@ -17,9 +18,11 @@
 void *withdraw(void *arg) {
   unsigned short amount = *(unsigned short *)arg;
 
+  pthread_mutex_lock(&account_mutex);
   // Ensure the user has enough money to complete this transaction
   if (amount > accountBalance) {
     printf("Insufficient funds for withdrawal of $%hu\n", amount);
+    pthread_mutex_unlock(&account_mutex);
     return NULL;
   }
 
@@ -29,6 +32,7 @@
   for (unsigned short i = 0; i < amount; i++) {
     --accountBalance;
   }
+  pthread_mutex_unlock(&account_mutex);
   return NULL;
 }
 
@@ -182,4 +186,4 @@
   if (accountBalance < -1000) {
     flag();
   }
-}
\ No newline at end of file
+}
```

### Explanation
To exploit this program we effectively exploit a TOCTOU bug where the threads each check a value, potentially sleep from some period, and then begin their decrementing loop. I added a mutex to protect the critial section of the code. Which means we have essentialliy returned this multithreaded program back to single threaded. This way each thread will process its entire job before allowing another thread to work on the same number.

---
