# Start Here

`Name`: Jackson Mowry
`NetID`: jmowry4

For each problem below, you will,

1. List the steps necessary to execute the exploit.
2. An explanation of what the vulnerability was.
3. An explanation of how you would patch the vulnerability.
4. If the challenge had a patch portion, enter the code used to patch the challenge.

--

## Scoreboard

### Steps
1. Enter the url `/#/score-board`

---

## DOM XSS

### Exploit steps
1. Enter '<iframe src="javascript:alert(`xss`)">' as the search term
### Explanation

The content written in the search box is directly reflected back into the DOM with sanitization, allowing for user content to be placed directly in the DOM.

### Patch
Not bypassing the built in sanitization from angular, allowing it to sanitize the content we get. 

### Patch code
```js
--- this.searchValue = this.sanitizer.bypassSecurityTrustHtml(queryParam)
+++ this.searchValue = queryParam
```

---

## Reflected XSS

### Exploit steps
1. Create an account, make a purchase, then on the track order page realize that the order id is reflected in the DOM. We can use this to inject a javascript alert call through the query parameter.

### Explanation
We must be bypassing the sanitization of the query parameters in the Angular framework, therefore we expose this section of code to being attacked, allowing attacker controlled content to make its way to the browser.

### Patch
Instead of bypassing santiization of query parameters I would simply use the default queryParameter method to enable sanitization.

### Patch code
Not applicable

---

## Forged Review

### Exploit steps
1. Order a product
2. Send a review so that we get a proper network request
3. Right click on the network request to edit and resend
4. Change to body to supply another username

### Explanation
The user is providing the name used for the review, which as we know can never be trusted. This is not being validated in any way and directly used for the review.

### Patch
Instead we should grab the users session cookie to get their username.

### Patch code
```js
--- { _id: req.body.id },
+++ { _id: req.body.id, author: user.data.email },
```

---

## Login Admin

### Exploit steps
1. Enter the username `' or 1=1; --` and password `--`
2. Profit

### Explanation
The username and password fields are being directly spliced into the SQL query, meaning this is vulnerable. We can use a SQL injection to select essentially all records, but only the first one will match, which is likely the admin as Dr. Ruoti explain in class.

### Patch
Use a proper sanitized SQL query that escapes any user controlled content not allowing for SQL injection. 

### Patch code
15		-	    models.sequelize.query(`SELECT * FROM Users WHERE email = '${req.body.email || ''}' AND password = '${security.hash(req.body.password || '')}' AND deletedAt IS NULL`, { model: UserModel, plain: true })
	17	+	    models.sequelize.query(`SELECT * FROM Users WHERE email = $1 AND password = $2 AND deletedAt IS NULL`,
	18	+	      { bind: [ req.body.email, security.hash(req.body.password) ], model: models.User, plain: true })

---

## Admin Section

### Exploit steps
1. Log in as admin
2. Go to the route `/administration`

### Explanation
We are exposing the entire routing table of our application on the front-end. 

### Patch
Instead we should host critial security sections of the application through a separate interface, not accessible through regular means. 

### Patch code
2		-	  {
	2	+	  /* TODO: Externalize admin functions into separate application
3		-	    path: 'administration',
	3	+	           that is only accessible inside corporate network.
4		-	    component: AdministrationComponent,
	4	+	   */
5		-	    canActivate: [AdminGuard]
	5	+	  // {
6		-	  },
	6	+	  //   path: 'administration',
	7	+	  //   component: AdministrationComponent,
	8	+	  //   canActivate: [AdminGuard]
	9	+	  // },

---

## Admin Registration

### Exploit steps
1. Go to the admin panel
2. Click to view a users details
3. The object that is returned has a "role" field which we can see is set to customer for most users, and admin for the admins
4. We can set this field while creating a user which hopefully won't be overwritten by the backend

### Explanation
Instead of explicitly setting all defaults for a customer, we deserialize whatever was given to use from the network request into an object, and set only a few fields. This allows for the user to set their own values for any fields which we do not explicitly set.

### Patch
We explicitly set all values for the user object that may be problematic.

### Patch code
	34	+	        context.instance.role = 'customer'

---

## API-Only XSS

### Exploit steps
1. Hunt for a field that we believe is stored in a database, and see if there is a way to update it
2. In my case I noticed that in `main.js` there is a reference to a host of endpoints under `/api/*`. 
3. One of these endpoints is responsible for the products, which should be an easy target
4. If we manually hit `/api/products` we are returned a JSON array of the entire store.
5. We can then modify the request from the entire store to a single item by appending `/3` to the end
6. The response contains the information for product 3, and we can then change this request to a `PUT` request, modify the description of the product, and finally update the headers to include `application/json` as the `Content-Type`, then send the request
7. Then when we return to the product page we are greeted with our alert popup.

### Explanation
We are explicitly trusting "user" (not really, but for the the sake of this example it is) controlled content, and then rendering it in the DOM. This leaves us vulnerable to a stored XSS attack whenever the user visits the produce card, and loads the description.

### Patch
Instead of manually bypassing the security of the Angular framework we can take advantage of its builtin sanitization by doing nothing! It will automatically sanitize content if we let it.

### Patch code
55		-	  }
56		-	
57		-	  trustProductDescription (tableData: any[]) {
58		-	    for (let i = 0; i < tableData.length; i++) {
59		-	      tableData[i].description = this.sanitizer.bypassSecurityTrustHtml(tableData[i].description)
60		-	    }

---
