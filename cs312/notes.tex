% Created 2024-09-17 Tue 10:12
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\date{\today}
\title{CS312 Notes}
\hypersetup{
 pdfauthor={},
 pdftitle={CS312 Notes},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{Theory Of Computation Introduction}
\label{sec:org410fd0c}
The 3 componenets of problem solving\\
\begin{enumerate}
\item Unknowns\\
\item Data\\
\item Conditions\\
\end{enumerate}

To solve a problem we need to find a way of determining the unknowns from given data such that conditions of the problem are satisfied.\\

The traditional areas of the theory of computation (TOC)\\
\begin{itemize}
\item Automata\\
\begin{itemize}
\item Provide problem solving devices\\
\end{itemize}
\item Computability\\
\begin{itemize}
\item Provide framework that can characterize devices by their computing power\\
\end{itemize}
\item Complexity\\
\begin{itemize}
\item Provide framework to classify problems acording to time/space complexity of the toold used to solve them\\
\end{itemize}
\end{itemize}
\subsection{Automata (Automaton)}
\label{sec:orgd37b676}
\begin{itemize}
\item Abstration of computing devices\\
\item How much memory can be used?\\
\item What operations can be performed?\\
\end{itemize}
\subsection{Computability}
\label{sec:org61d48be}
\begin{itemize}
\item Study different computing models and identify the most powerful ones\\
\item Range of problems\\
\item Problems can be undecidable or uncomputatble\\
\begin{itemize}
\item The halting problem\\
\end{itemize}
\end{itemize}
\subsection{Complexity}
\label{sec:org00ad0a2}
\begin{itemize}
\item Computing problems range from easy to hard; sorting is easier than scheduling\\
\item Question\\
\begin{itemize}
\item What makes some problems computationally hard or others easy?\\
\end{itemize}
\end{itemize}
\subsection{Problem Abstration}
\label{sec:orgb77e2b3}
Data\\
\begin{itemize}
\item Abstracted as a word in a given alphabet\\
\end{itemize}
Conditions\\
\begin{itemize}
\item Abstracted as a set of words called a language\\
\end{itemize}
Unknowns\\
\begin{itemize}
\item A boolean variable: true if a word is in the language or false other wise\\
\end{itemize}
\subsubsection{Abstration of Data}
\label{sec:org775dffb}
\begin{itemize}
\item \(\Sigma\): alphabet, a finite, nonempty set of symbols\\
\item \(\Sigma\)\textsuperscript{*}: all words of a finite length built up using \(\Sigma\)\\
\item Rules: (1) the empty word (\(\epsilon\)) is in \(\Sigma\)\textsuperscript{*}; (2) if w \(\in\) \(\Sigma\)\textsuperscript{*} and a \(\in\) \(\Sigma\), then aw \(\in\) \(\Sigma\)\textsuperscript{*}, and (3) nothing else is in \(\Sigma\)\textsuperscript{*}\\
\end{itemize}

Example: If \(\Sigma\) = \{0,1\}, then \(\Sigma\)\textsuperscript{*} = \{\(\epsilon\),0,1,00,01,10,11,000,001,010,011,\ldots{}\}.\\
\begin{enumerate}
\item Valid C
\label{sec:org2572441}
\begin{verbatim}
int my_func() { return 1; };

int main() {
    int var = my_func(1,2,3,4,5,6,7);
    for (;;) {}
    // You cannot just simply change the syntax of a for loop
    for(;) {}
}
\end{verbatim}
\item Invalid C++
\label{sec:org443414e}
\begin{verbatim}
int my_func() { return 1; };

int main() {
    int var = my_func(1,2,3,4,5,6,7);
    for (;;) {}
    // You cannot just simply change the syntax of a for loop
    for(;) {}
}
\end{verbatim}
\end{enumerate}
\section{Finite Automata}
\label{sec:org402d0ba}
\subsection{Formal Language}
\label{sec:org3845366}
\begin{itemize}
\item Some set of strings over a give alphabet\\
\item How do you specify a language?\\
\item How do you recognize strings in a language?\\
\item How do you translate the language?\\
\end{itemize}
\subsection{Abstraction of Problems}
\label{sec:orge6a54c4}
\begin{enumerate}
\item Data - word in a given alphabet\\
\begin{itemize}
\item \(\Sigma\) alphabet, a finite non-empty set of symbols\\
\item \(\Sigma\)\textsuperscript{*} all words of finite length built-up using \(\Sigma\)\\
\end{itemize}
\item Conditions - Set of words called a language\\
\begin{itemize}
\item Any subset L \subseteq \(\Sigma\)\textsuperscript{*} is a formal language\\
\end{itemize}
\item Unknown - a boolean variable that is true, if word is in language; false, otherwise.\\
\begin{itemize}
\item Given w \(\in\) \(\Sigma\)\textsuperscript{*} and L \subseteq \(\Sigma\)\textsuperscript{*}, is w \(\in\) L?\\
\end{itemize}
\end{enumerate}
\subsection{Formal Definition}
\label{sec:org54ee7e7}
\begin{itemize}
\item Simplest computational model also referred to as a finite-state machine or finite automaton (FA)\\
\item Representations: graphical, tabular, and mathmatical\\
\item A finite automaton is a 5-tuple (Q,\(\Sigma\),\(\delta\),q\textsubscript{0},F), where Q is a finite set of states, \(\Sigma\) is a finite set of symbols (alphabet), the transition function \(\delta\) maps Q X \(\Sigma\) to Q, q\textsubscript{0} \(\in\) Q is the start (initial) state, and F \(\subseteq{}\) Q is the set of accept (final) states\\
\item Used to design embedded systems, or compilers\\
\end{itemize}
\subsubsection{Example}
\label{sec:orgf5248f2}
If the machine is in a start state, where the initial state is an accept state, that means that our FA can accept an empty string \(\epsilon\)\\
\subsection{DFA}
\label{sec:orga870dfe}
Deterministic Finite Automata\\
\subsection{Applications}
\label{sec:orgf723eb7}
\begin{itemize}
\item Parsers for compilers\\
\item Pattern recognition\\
\item Speech processing and OCR\\
\item Financial planning and market prediction\\
\end{itemize}
\subsection{FA Computation}
\label{sec:org1a650e2}
\begin{itemize}
\item Automaton M\textsubscript{1} receives input symbols one-by-one (left to right)\\
\item After reading each symbol, M\textsubscript{1} moves from one state to another along the transition that has that symbol as its label\\
\item When M\textsubscript{1} reads the last symbol of the input, it produces the output: accept if M\textsubscript{1} is in an accept state, or reject if M\textsubscript{1} is not in an accept state\\
\end{itemize}
\subsection{Language Recognition}
\label{sec:org8b692b9}
\begin{itemize}
\item If L is the set of all strings that an FA M accepts, we say that L is the language of the machine M and write L(M) = L\\
\item An automaton may accept several strings, but it always recognizes only one language\\
\item If a machine accepts no strings, it still recognizes one language, namely the empty language 0\\
\end{itemize}
The machines are recognizing words in the language\\
Any given automaton only recognizes specifically one language\\
\subsection{Formal Definition of Acceptance}
\label{sec:org96051de}
\begin{itemize}
\item LEt M = (Q,\(\Sigma\),\(\delta\),q\textsubscript{0},F) be an FA and w = a\textsubscript{1}a\textsubscript{2}\ldots{}a\textsubscript{n} be a string over \(\Sigma\). We say M accepts w if a sequence of states r\textsubscript{0}r\textsubscript{1}\ldots{}r\textsubscript{n} exist in Q such that\\
\begin{itemize}
\item r\textsubscript{0} = q\textsubscript{0} (where machine starts)\\
\item \(\delta\)(r\textsubscript{i},a\textsubscript{i+1}) = r\textsubscript{i+1}, i=0,1,\ldots{},n-1,(transitions based on \(\delta\))\\
\item r\textsubscript{n} \(\in\) F (input accepted)\\
\end{itemize}
\end{itemize}
\subsection{Regular Languages}
\label{sec:orgc93955c}
\begin{itemize}
\item We say that FA recognizes the language L if L = \{w | M accepts w\}\\
\item A language is called a \textbf{regular} language, if there exists an FA that recognizes it\\
\item Q: how do you design/build an FA\\
\end{itemize}
\subsection{FA Design Approach}
\label{sec:org373504e}
\begin{enumerate}
\item Identify finite pieces of information you need, i.e., the states (possibilities)\\
\item Identify the condition (or alphabet) to change from one state to another\\
\item Idenitfy the starting and final/accept states\\
\item Add missing transitions\\
\end{enumerate}
\subsection{Example}
\label{sec:orgdc9b53b}
Let M\textsubscript{1} = (Q,\(\Sigma\),\(\delta\),q\textsubscript{1},F), Q = \{q\textsubscript{1},q\textsubscript{2},q\textsubscript{3}\}, \(\Sigma\) = \{0,1\}, and F = \{q\textsubscript{2}\}. Let's define a transition functoin \(\delta\) for M\textsubscript{1} and then draw the resulting (graph-based) \textbf{state transition diagram} for M\textsubscript{1}\\

DFA, this table is Q X \(\Sigma\) \(\rightarrow\) Q\\
q\textsubscript{1} is the start state\\
q\textsubscript{2} is the accept\\

\begin{center}
\begin{tabular}{lll}
 & 0 & 1\\
\hline
q\textsubscript{1} & q\textsubscript{1} & q\textsubscript{2}\\
q\textsubscript{2} & q\textsubscript{3} & q\textsubscript{2}\\
q\textsubscript{3} & q\textsubscript{2} & q\textsubscript{2}\\
\end{tabular}
\end{center}

\tikzset{
        ->, % makes the edges directed
        node distance=3cm, % specifies the minimum distance between two nodes. Change if necessary.
        every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
        initial text=$ $, % sets the text that appears on the start arrow
}


\begin{tikzpicture}
        \node[state, initial] (q1) {$q_1$};
        \node[state, accepting, right of=q1] (q2) {$q_2$};
        \node[state, right of=q2] (q3) {$q_3$};
        \draw (q1) edge[loop above] node{0} (q1)
        (q1) edge[above] node{1} (q2)
        (q2) edge[loop above] node{1} (q2)
        (q2) edge[bend left, above] node{0} (q3)
        (q3) edge[bend left, below] node{0, 1} (q2);
\end{tikzpicture}
\subsubsection{Notes on Example}
\label{sec:org2d31f36}
L(M\textsubscript{1}) = ?\\
L(M\textsubscript{1}) = A\\
A = \{w | w contains at least one 1 AND an event number of 0's following the last 1\}\\
\subsection{Example 2}
\label{sec:orged83b10}
\(\delta\)  Q X \(\Sigma\) \(\rightarrow\) Q\\

\begin{center}
\begin{tabular}{lll}
 & 0 & 1\\
\hline
q\textsubscript{1} & q\textsubscript{1} & q\textsubscript{2}\\
q\textsubscript{2} & q\textsubscript{1} & q\textsubscript{2}\\
\end{tabular}
\end{center}

\begin{tikzpicture}
        \node[state, initial] (q1) {$q_1$};
        \node[state, accepting, right of=q1] (q2) {$q_2$};
        \draw (q1) edge[loop above] node{0} (q1)
        (q1) edge[bend left, above] node{1} (q2)
        (q2) edge[loop above] node{1} (q2)
        (q2) edge[bend left, below] node{0} (q1)
\end{tikzpicture}

L(M\textsubscript{2}) = B = \{ w | w ends in a 1 \}\\
\subsubsection{Expanstion on Above M\textsubscript{3}}
\label{sec:org2ac5e60}

\begin{tikzpicture}
        \node[state, initial, accepting] (q1) {$q_1$};
        \node[state, right of=q1] (q2) {$q_2$};
        \draw (q1) edge[loop above] node{0} (q1)
        (q1) edge[bend left, above] node{1} (q2)
        (q2) edge[loop above] node{1} (q2)
        (q2) edge[bend left, below] node{0} (q1)
\end{tikzpicture}

Language of M\textsubscript{3} = C = \{ w | w ends in a 0 OR w is empty \}\\
\subsubsection{What does this give us?}
\label{sec:org3e1f373}
If we flip the accept and initial state, we generate the complement of the machine (flip the meaning)\\
\subsection{Last DFA Example}
\label{sec:org191044a}
Q=\{s,q\textsubscript{1},q\textsubscript{2},r\textsubscript{1},r\textsubscript{2}\}\\
\(\Sigma\)=\{a,b\}\\
F = \{q\textsubscript{1},r\textsubscript{1}\}\\

\(\Delta\) chart\\
\begin{center}
\begin{tabular}{lll}
 & a & b\\
\hline
s & q\textsubscript{1} & r\textsubscript{1}\\
q\textsubscript{1} & q\textsubscript{1} & q\textsubscript{2}\\
q\textsubscript{2} & q\textsubscript{1} & q\textsubscript{2}\\
r\textsubscript{1} & r\textsubscript{2} & r\textsubscript{1}\\
r\textsubscript{2} & r\textsubscript{2} & r\textsubscript{1}\\
\end{tabular}
\end{center}

\begin{tikzpicture}
        \node[state, initial] (s) {$s$};
        \node[state, accepting, right of=s] (q1) {$q_1$};
        \node[state, accepting, left of=s] (r1) {$r_1$};
        \node[state, below of =q1] (q2) {$q_2$};
        \node[state, below of =r1] (r2) {$r_2$};
        (s) edge[] node{a} (q1)
        (s) edge[] node{b} (r1)
        (q1) edge[loop above] node{a} (q1)
\end{tikzpicture}

\{ w | starts with 'a' AND ends with 'a' \}\\
\section{Regular Languages}
\label{sec:org79abade}
Let A and B be languages\\
Union: A \union B = \{ x | x \(\in\) A \(\vee\) x \(\in\) B \}\\
Concatenation: A \^{} B = \{ xy | x \(\in\) A \(\wedge\) y \(\in\) B \}\\
Star: A\textsuperscript{*} = \{ x\textsubscript{1}x\textsubscript{2}\ldots{}x\textsubscript{k} | k >= 0 \(\wedge\) x\textsubscript{i} \(\in\) A, 0 <= i <= k \}\\
\subsubsection{Is \(\epsilon\) always a member of A\textsuperscript{*} regarless of the language A?}
\label{sec:org7ae2c9c}
Yes\\
\subsubsection{What is another name for the language of A \^{} A\textsuperscript{*}?}
\label{sec:org3a29740}
A\textsuperscript{+}\\
\subsubsection{Closures of Regular Languages}
\label{sec:orgf2eaeb2}
Theorem: Class of regular languages is closed under intersection. (Proof: Use cross-product construction of states)\\
Theorem: Class of regular languages is closed under complementation (Proof: swap accept/non-accept states and show FA recognizes the complement)\\
\subsection{Nondeterminism}
\label{sec:orgafb1fba}
NFA or nondeterministic finite automata\\
\begin{itemize}
\item Every stop of a FA computation follows in a unique way from the proceeding step; a deterministic computation\\
\item Nondeterministic computation - choices exist for the next state; a nondeterministic FA (NFA)\\
\item Ways to introduct nondeterminism\\
\begin{itemize}
\item more choices for next state (zero, one, many)\\
\item State may change to another state without reading any symbol\\
\end{itemize}
\end{itemize}
\subsubsection{Formal Definition}
\label{sec:org16a63b7}
a 5-tuple (Q, \(\Sigma\), \(\delta\), q\textsubscript{0}, F), where Q is a finite set of states, \(\Sigma\) is a finite set of symbols (alphabet), the transition function \(\delta\) maps Q x \(\Sigma\) \union \{\(\epsilon\)\} to \mathbb{P}(\mathbb{Q}), q\textsubscript{0} \(\in\) Q is the start (initial) state, and F \(\subseteq{}\) Q is the set of accept (final) states.\\

Notice that the range of the transition function \(\delta\) for an NFA is the power set of Q \mathbb{P}(\mathbb{Q})\\
\subsubsection{Formal Definition of Acceptance (NFA)}
\label{sec:orgb84cb81}
Let N  k (Q, \(\Sigma\), \(\delta\), q\textsubscript{0}, F) be an NFA and w = y\textsubscript{1}y\textsubscript{2}\ldots{}y\textsubscript{n} be a string over \(\Sigma_{\epsilon}=\Sigma{}\union{}{\epsilon}\). We say N accepts w if a sequence of states r\textsubscript{0},r\textsubscript{1},\ldots{},r\textsubscript{m} exist in Q such that\\
\begin{enumerate}
\item r\textsubscript{0} = q\textsubscript{0}\\
\item \(\delta\)(r\textsubscript{i},y\textsubscript{i+1}) = r\textsubscript{i+1} for i = 0,1,\ldots{},m-1\\
\item r\textsubscript{m}\(\in\)F\\
\end{enumerate}
\subsubsection{NFA Motivation}
\label{sec:org9d629ac}
\begin{itemize}
\item For some problems they are much easier to construct than a DFA\\
\item NFA may actually be smaller than a DFA that performs the same task; but NFA computation is usually more expensive\\
\item Every NFA can be converted into an equivalent DFA (in theory, every NFA has an equivalent DFA t orecognize the same language)\\
\item NFAs can be used to show that regular languages are closed under union, concatenation, and star operations\\
\end{itemize}

Epsilon transitions happen without reading anything, allowing you to go either direction\\
\subsubsection{DFA/NFA Equivalence}
\label{sec:orgae015f3}
Let N = (Q, \(\Sigma\), \(\delta\), q\textsubscript{0}, F) be the NFA that recognizes the language A and construct the DFA M that also recognizes A. Define M = (Q', \(\Sigma\), \(\delta\)', q\textsubscript{0}', F').\\


E(R) = R \Union \{q \(\in\) Q | \quantifier{}r\textsubscript{1} \(\in\) R,r\textsubscript{2},\ldots{},r\textsubscript{k} \(\in\) Q, r\textsubscript{i+1} \(\in\) \(\delta\)(r\textsubscript{i},\(\epsilon\)), r\textsubscript{k} = q\}\\
\section{Nonregular Languages}
\label{sec:org005b7bd}
R is a regular expression if\\
\begin{enumerate}
\item a for some a \(\in\) \(\Sigma\)\\
\item \(\epsilon\) (language contains only the empty string)\\
\item 0 (language has no strings)\\
\item (R\textsubscript{1} \union R\textsubscript{2}), where R\textsubscript{1}, R\textsubscript{2} are regular expressions\\
\item (R\textsubscript{1} \^{} R\textsubscript{2}), where R\textsubscript{1}, R\textsubscript{2} are regular expressions\\
\item R\textsubscript{1}\textsuperscript{*}, where R\textsubscript{1} is a regular expression\\
\end{enumerate}
\subsection{Language Example}
\label{sec:orgbbf7ebb}
Is B = \{0\textsuperscript{n}1\textsuperscript{n}|n \(\ge\) 0\} a regular language?\\
\begin{itemize}
\item No because one single machine cannot possible match the infinte states\\
\end{itemize}
\subsubsection{Warning}
\label{sec:org3ddf7ea}
Just because a language might seem to require unbounded (infinite) memory t orecognize it - it could still be regular\\

Suppose you have the following two languages: C = \{w | w has an equal number of 0s and 1s\} and D = \{w | w has an equal number of 01 and 10 substrings\}\\

2nd is regular?\\
\subsection{Example}
\label{sec:org717321a}
Language D = \{w|w has an equal number of 01 and 10 substrings\}\\

We can generally create a regular language if the constraints are ordering\\
Generally non-regular if we have to do some sort of counting without ordering\\
\section{Pumping Lemma}
\label{sec:orgb23cace}
\begin{itemize}
\item All strings in a language can be pumped if they are at least as long as a certain value called the pumping length\\
\item Another interpretation: every string contains a section that can be repeated any number of itmes with the resulting string remaining in the language\\
\end{itemize}
\subsection{Example}
\label{sec:orgf20853b}
sqrt(sqrt(sqrt(\ldots{}sqrt(x)\ldots{})))\\
\subsection{Lemma}
\label{sec:org80bd5ea}
If A is a regular language, then there exists a number p (the pumping length) where, if s is any string in A of length of at least p, then s may be divided into three pices, s = xyz subject too\\

If you take any string out of the language, at least length p, then I can take that string, cut it into pieces, 3 pieces, prefix x, suffix z,\\

\begin{enumerate}
\item \(\forall\) i \(\ge\) 0, xy\textsuperscript{i}z \(\in\) A\\
\begin{itemize}
\item p is an integer\\
\item You can also remove all y's, 0 y's\\
\end{itemize}
\item |y| > 0\\
\begin{itemize}
\item The actual substring must have some chars\\
\item x and z can both be empty strings\\
\end{itemize}
\item |xy| \(\le\) p\\
\begin{itemize}
\item the length of x+y cannot be bigger than p\\
\end{itemize}
\end{enumerate}
\subsection{Pumping Lemma Proof Construction}
\label{sec:org0169d8a}
\begin{itemize}
\item Let M = (Q,\(\Sigma\),\(\delta\),q\textsubscript{1},F) be a DFA that recognizes the language A. Assign a pumping length p to the number of states of M.\\
\begin{itemize}
\item P (pumping length) is the number of states in M, which is finite\\
\item If you have finite number of states (p), and it is way bigger than p, then we will have to loop\\
\end{itemize}
\item Show that any string s \(\in\) A, |s| \(\ge\) p may be broken into xyz satisfying the three PL conditions\\
\begin{itemize}
\item 
\end{itemize}
\item If there are no strings in A of length at least p, then the PL is true because all three conditions hold for all strings of length at least p (if there are NO such strings)\\
\end{itemize}
\subsection{Proof}
\label{sec:org1a48050}
Recognizes A and let p be the size of Q, let s = s\textsubscript{1}s\textsubscript{2}\ldots{}s\textsubscript{n} be a string over \(\Sigma\) with n \(\ge\) p and r = r\textsubscript{1}r\textsubscript{2}\ldots{}r\textsubscript{n+1} be the sequence of states encountered while processing\\
\subsubsection{Example}
\label{sec:org8e6460e}
We know that n+1 \(\ge\) p+1, why?\\
\begin{itemize}
\item because n \(\ge\) p\\
\end{itemize}

The among the first p+1 elements in the sequence r\ldots{}, there must be a repeating state, say r\textsubscript{j},r\textsubscript{k} what principle is this based on?\\
\begin{itemize}
\item Pigeon hole principle\\
\end{itemize}

Let r\textsubscript{k} be the recurring state among the first p+1 states in the sequence starting with r\textsubscript{1}, so k \(\le\) p+1. Let x = s\textsubscript{1}s\textsubscript{2}\ldots{}s\textsubscript{j-1}, y = s\textsubscript{j}s\textsubscript{j+1}\ldots{}s\textsubscript{k-1}, and z = s\textsubscript{k}s\textsubscript{k+1}\ldots{}s\textsubscript{n}\\

So X takes M from r\textsubscript{1} to r\textsubscript{j}, Y takes M from r\textsubscript{j} to r\textsubscript{j} and Z takes M from r\textsubscript{j} to r\textsubscript{n+1}; recall that r\textsubscript{j} == r\textsubscript{k} and that r\textsubscript{n+1} is an accept state\\
Therefore:\\
\begin{itemize}
\item M must accept xy\textsuperscript{i}z, for i \(\ge\) 0 (\textbf{Condition 1})\\
\item Since j \(\neq\) k then |y| \textgreater{} 0 (\textbf{Condition 2})\\
\item Since k \(\le\) p + 1 then |xy| \(\le\) p (\textbf{Condition 3})\\
\end{itemize}
\subsection{Technique}
\label{sec:org985bb6d}
\begin{itemize}
\item Assume the language is regular, and assume a contradiction\\
\item PL guarantees existence of a pumping length p such that all strings of length p or greater (in A) can be pumped\\
\item Find s \(\in\) A, |s| \(\ge\) p that cannot be pumped; consider all the ways of dividing s int ox,y,z and show that for each division, at least one of the PL conditions fail to hold\\
\item pumping length = number of states in a minimalist machine\\
\end{itemize}
\subsubsection{Example}
\label{sec:org3cf5584}
B = \{0\textsuperscript{n}1\textsuperscript{n} | n \(\ge\) 0\} is not regular\\

Assume B is regular and let p be the pumping length for B. Choose s = 0\textsuperscript{p}1\textsuperscript{p} \(\in\) B so that clearly s \(\ge\) p. By the PL, we can partition s = xyz such that for all i \(\ge\) 0, xy\textsuperscript{i}z \(\in\) B. Let's consider three possible cases for the contents of substring y\\

Think about what the string is, in our case s = 00\ldots{}011\ldots{}1, where our length is now 2p, p 0's followed by p 1's.\\

\begin{center}
\begin{tabular}{rrr}
x & y & z\\
000 & 0011 & 111\\
\end{tabular}
\end{center}
\begin{enumerate}
\item Options
\label{sec:org785946a}
\begin{enumerate}
\item Y consists of only 0's\\
\begin{itemize}
\item x   | y  | z\\
\item 0000|\ldots{}0|111.11\\
\item Then S' = xyyz\\
\item Then S' has more 0's than 1's, therefore it is no longer in the language\\
\item Hence, xyyz \(\notin\) B, a violation of condition 1 of the PL\\
\item Y consists only of 0's. Then S' = xyyz has more 0's than 1's since |y| > 0 by condition 2. Hence, xyyz \(\notin\) B. This is a violation of condition 1 of the PL.\\
\end{itemize}
\item Y consists of only 0's\\
\begin{itemize}
\item Y consists only of 1's. Then S' = xyyz has more 1's than 0's since |y| > 0 by condition 2. Hence, xyyz \(\notin\) B. This is a violation of condition 1 of the PL.\\
\end{itemize}
\item Y consists of 0's and 1's\\
\begin{itemize}
\item Y consists of 0's and 1's. Then s' = xyyz may have the same number of 0's and 1's, but they are out of order (i.e some 1's occur before 0's), and so s' = xyyz \(\notin\) B. This is a violation of condition 1 of the PL.\\
\end{itemize}
\end{enumerate}
\end{enumerate}
\subsection{How might the proof above be simplified using condition 3 of the PL to constrain the contents of the substring y?}
\label{sec:orgaf71510}
According to condition 3, we must have |xy| <= p.\\

We picked s = 0000000|1111111, both of length p\\
xy is already p length, therefore the language only contains 0's.\\
y could only contain 0's and we have contradiction in case 1 for all y\\
\subsubsection{Example}
\label{sec:org86a2a1d}
i = 2\\
New string is xz\\
\subsection{Conditions}
\label{sec:orgb92e292}
\begin{itemize}
\item If a language is regular, one should be able to take any string out of that language, partition it into 3 parts XYZ, with the Y componenet having something in it, then you can pump that string\\
\item \(\forall\) i \(\ge\) 0, XY\textsuperscript{i}Z has to be in the language, if i = 0 we are pumping down, if i \textgreater{} 1 we are pumping up\\
\item We only have to find one i that breaks the conditions, because the condition says \(\forall\) i's\\

\item if i = 1, then we are not pumping, that is just the same string\\
\item When i \(\ge\) 2 then we are pumping up\\
\item When i \eq 0 then we are pumping down\\
\end{itemize}
\subsection{Example Again}
\label{sec:orgf15061d}
Use the PL to prove that the language E = \{0\textsuperscript{i}1\textsuperscript{j} | i > j\} is not regular.\\

Assume E is regular and let p be the pumping length for E. Choose s = 0\textsuperscript{p+1}1\textsuperscript{p} \(\in\) E so that clearly s > p. By the PL, we can partition s = xyz such that for all i >= 0, xy\textsuperscript{i}z \(\in\) E. By condition 3 of the pumping lemma, we must have |xy| \(\le\) p. Therefore, y must contain only 0's. Is it possible for s' = xyyz to be in the language? Adding an additional copy of y increases the number of 0's which does not violate the constraints of the language. But setting i = 0 does violate the condition since we would now have 0\textsuperscript{p} and 1\textsuperscript{p}, or more generally i <= j. Subsequently s' would \(\notin\) E, given this contradiction of conditoin 1 of the PL, we can conclude E is not regular.\\

Start with condition 3 of the PL to determine the contents of substring y and see if you can get a violation of Condition 1 of the PL for any choice of y.\\
\subsection{Another example}
\label{sec:orgdef5c47}
\subsubsection{Language 1}
\label{sec:org5a7d5c4}
L\textsubscript{1} = \{a\textsuperscript{i}ba\textsuperscript{j} | 0 \(\le\) i < j\}\\
\begin{itemize}
\item ba\\
\item Assume L\textsubscript{1} is regular with pumping length p\\
\item Choose s = a\textsuperscript{p}ba\textsuperscript{p+1}\\
\item State cond 1, s = xyz \(\forall\) i \(\ge\) 0 xy'z \(\in\) L\textsubscript{1}\\
\item Use condition 3 (|xy| \(\le\) p), and condition 2 (|y| > 0)\\
\item y contains only a's\\
\item Pumping up violates the constraint i < j, because xyyz would result in i is now greater than j, which means j is no longer strictly greater than i\\
\item Therefore s' \(\notin\) L\textsubscript{1}, a's before b are greater than or equal to those after b\\
\end{itemize}
\section{Context Free Languages}
\label{sec:org30a3deb}
We have shown that L = \{0\textsuperscript{n}1\textsuperscript{n} | n \(\ge\) 0\} cannot be specified by a FA or regular expression; Context-Free Grammars (or CFGs) provide a more powerful way to specify languages. A CFG is a 4-tuple (V, \(\Sigma\), R, S), where\\
\begin{itemize}
\item V is a finite set of symbols (variable or nonterminals)\\
\item \(\Sigma\) is a finite set of symbols disjoint from V (terminals)\\
\item R is a finite set of specification rules of the form \emph{lhs} \(\rightarrow\) \emph{rhs}, \emph{lhs} \(\in\) V, \emph{rhs} \(\in\) (V \union \(\Sigma\)), and S \(\in\) V is the start variable\\
\end{itemize}
\subsection{Example}
\label{sec:orga4405cb}
CFG G\textsubscript{1} has the following specification rules\\
\[
A \rightarrow{} 0A1
\]\\
\[
A \rightarrow{} B
\]\\
\[
B \rightarrow{} \#
\]\\

The start variable for G\textsubscript{1} is A.\\
What are the nonterminals?\\
\begin{itemize}
\item A, B\\
\end{itemize}
What are the terminals?\\
\begin{itemize}
\item 0, 1, \#\\
\end{itemize}
\subsection{Language Specification}
\label{sec:org522900e}
\begin{enumerate}
\item Write down start variable; \emph{lhs} of first spec rule\\
\item Find variable that is written down and a rule whose \emph{lhs} is that variable; replace the written down variable with the \emph{rhs} of that rule\\
\item Repeat Step 2 until no variables remain in string\\
\end{enumerate}
\subsubsection{Example}
\label{sec:org65bf778}
Use the CFG G\textsubscript{1} (above) to derive the string 000\#111. Show derivation and corresponding parse tree\\
\subsection{Direct Derivation}
\label{sec:org9ccd111}
If u,v,w \(\in\) (V \union \(\Sigma\))\textsuperscript{*}, i.e., are strings of variables and terminals, and A \(\rightarrow\) w \(\in\) R is a grammar rule, then we say that uAv yields uwv or uAv \(\Rightarrow\) uwv. Alternatively, uwv is directly derived from uAv using the rule A \(\rightarrow\) w.\\
\subsection{Derivation}
\label{sec:org54b9b75}
\[
S \rightarrow aSb
\]\\
\[
S \rightarrow SS
\]\\
\[
S \rightarrow \epsilon
\]\\
\subsection{Applications}
\label{sec:orgfc372ad}
\begin{itemize}
\item Compiler design and implementation\\
\item Programming language specificatoin\\
\item Scanner, parsers, and code generators\\
\end{itemize}
\subsection{Design Techniques}
\label{sec:orge5ff949}
\begin{enumerate}
\item CFG Design Technique\\
\begin{itemize}
\item Many CFGs are unions of simpler CFGs\\
\item Combination involves putting all the rules together and adding the new rules\\
\item s \(\rightarrow\) s\textsubscript{1}|s\textsubscript{2}|\ldots{}|s\textsubscript{k}\\
\begin{itemize}
\item where the variables s\textsubscript{i}, 1 \(\le\) i \(\le\) k, are the start variables of the invidivual grammars and the s is a new variable\\
\end{itemize}
\end{itemize}
\end{enumerate}

\begin{verbatim}
int a = 5;

return a + a a;
\end{verbatim}
\subsubsection{Design a Language Example}
\label{sec:orge4bb461}
CFG G = (\{S,B\}, \{a,b\}, \{S \(\rightarrow\) aSB|B|\(\epsilon\), B \(\rightarrow\) bB|b\} S)\\

\{a\textsuperscript{n}b\textsuperscript{m} | n <= m\}\\
\subsection{Ambiguous Grammar}
\label{sec:org47149ca}
Consider the CFG G\textsubscript{5} that has the rules E \(\rightarrow\) E + E | E * E | (E) | a.\\

For this out by parsing left to right\\
\subsubsection{Derivation Order}
\label{sec:org9fe573a}
It is possible for 2 derivations to produce hte same derivation becuase htey differ in the order\\

Leftmost derivation, replace the leftmost nonterminal first\\
Rightmost Derivation, replace the rightmost nonterminal at each step\\
\subsubsection{Example}
\label{sec:org166334b}
\(\Sigma\) = \{a,b,c\}\\
A = \{a\textsuperscript{i}b\textsuperscript{j}c\textsuperscript{k} | i = j \(\vee\) j = k \hat{} (i,j,k \(\ge\) 0)\}\\

Rules\\
\begin{itemize}
\item S \(\rightarrow\) E\textsubscript{ab}C | AE\textsubscript{bc}\\
\item E\textsubscript{ab} \(\rightarrow\) aE\textsubscript{ab}b | \(\epsilon\)\\
\end{itemize}
\end{document}
