<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>/Memory Allocator/</title>
<meta name="author" content="Jackson" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
/* Base */html,body {    background-color: #222;    min-height: 100%;    line-height: 1.5;}body {    color: #fafafa;    font-family: "Courier New";}::selection {    background-color:  #2ecc40;    color: white;}/* Responsive content positioning */@media only screen and (min-width: 1020px) /* Large screens */{    body{        padding: 10vh 20vw;    }}@media only screen and (max-width: 1020px) and (min-width: 750px) /* Small screens */{    body{        padding: 5vh 10vw;    }}@media only screen and (max-width: 750px) /* Small screens */{    body{        padding: 2vh 5vw;    }}/* Headers */h1{font-size: 2.5rem;}h2{font-size: 1.7rem;}h1 > .subtitle, h3, h4, h5, h6{color: #999; font-size: 1.3rem;}.title{    margin-bottom: 2.5rem;}/* Padding & Margin */* {margin: 0; padding: 0;}pre, blockquote, ul, ol, p, table{    margin: 1rem 0;}h1, h2{margin-top: 2rem; line-height: 2rem;}h3, h4, h5, h6{margin-top: 1rem;}/* Links  */a, a:visited {    color: #01ff70;    text-decoration: underline;}a:hover, a:focus, a:active {    color: #2ecc40;}/* Code */pre {    font-family: "Courier New";    padding: .5rem;    background-color: #333;    padding: 0.5rem;    border-radius: 0.2rem;    font-size: 0.9rem;    color: #EEE;    overflow-x: auto;}.org-keyword{    color: #01ff70;}.org-rainbow-delimiters-depth-1{    color: #2ecc40;}.org-rainbow-delimiters-depth-2{    color: #01ff70;}/* Blockquotes */blockquote {    border-left: 3px solid #01ff70;    padding-left: 1rem;}li{    list-style-position: inside;}/* Tags */.tag{    margin-top: 0.5rem;    display: block;    color: white;    font-size: var(--font-size-xsmall);}.tag > span{		font-weight: 400;    font-size: 0.8rem;    background-color: #444;    text-transform: uppercase;    border-radius: 2px;    width: fit-content;    height: auto;    padding: 1px 5px;}/* Keywords */.todo{    color: #2ecc40;}.done{    color: #444;}/* Overflows */.outline-text-2, .outline-text-3, .outline-text-4{	  max-width: 100%;	  overflow-x: auto;}/* Table */tr:nth-child(even) {    background-color: #333;}th, td{    padding: 0.5rem;    text-align: center;}.underline{    text-decoration: underline;}img{    max-width: 100%;    height: auto;} pre.example{color: white; overflow-x: hidden; white-space: pre-wrap;} .example:hover{ color: white;} /*h3,h4,h5,h6{text-decoration: underline;}*/ code{background-color: white; padding: .08em .4em; color: black; border-radius: 6px; margin: 0 .1em; font-size: 120%;} #postamble { font-size: 80%; color: gray; margin-top: 2rem;} #org-div-home-and-up a:first-child {display: none;}
</style>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title"><i>Memory Allocator</i></h1>
<div id="outline-container-orgadc7c8d" class="outline-2">
<h2 id="orgadc7c8d"><span class="underline">Introduction</span></h2>
<div class="outline-text-2" id="text-orgadc7c8d">
<p>
We use memory allocators nearly every time we write software. They allow our programs to be dynamic and handle a wide variety of input, or user interactions. In languages like C the programmer interacts directly with the memory allocator through calling <code>malloc()</code> and <code>free()</code>. Higher level languages extract away the need for the programmer to worry about memory management, usually through a garbage collector. But what does a memory allocator do? Hopefully we can figure that out through exploring one possible implementation.
</p>
</div>
</div>
<div id="outline-container-org023f648" class="outline-2">
<h2 id="org023f648"><span class="underline">Headers</span></h2>
<div class="outline-text-2" id="text-org023f648">
<p>
Here are all the headers I believe we will need to complete this project. Apologies if we don&rsquo;t end up using some of them, just try to cover my bases.
</p>
<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;assert.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdbool.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdint.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdlib.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;string.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;unistd.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">"gallocc.h"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#if</span><span style="color: #85DDFF; font-weight: bold;">n</span><span style="color: #85DDFF; font-weight: bold;">def</span> GALLOCC_H_
<span style="color: #85DDFF; font-weight: bold;">#define</span> <span style="color: #85DDFF;">GALLOCC_H_</span>

<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdlib.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdbool.h&gt;</span>

<span style="color: #85DDFF; font-weight: bold;">#define</span> <span style="color: #85DDFF;">HEAP_INC</span> <span style="color: #B5CEA8; font-weight: bold;">1024</span>

<span style="color: #339CDB;">typedef</span> <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> {
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>;
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span>;
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_free</span>;
} <span style="color: #35CDAF;">heap_seg</span>;

<span style="color: #35CDAF;">size_t</span> <span style="color: #D9DAA2;">round_bytes</span>(<span style="color: #35CDAF;">size_t</span>);

<span style="color: #35CDAF;">bool</span> <span style="color: #D9DAA2;">segment_free</span>(<span style="color: #35CDAF;">heap_seg</span>*);
<span style="color: #35CDAF;">size_t</span> <span style="color: #D9DAA2;">segment_size</span>(<span style="color: #35CDAF;">heap_seg</span>*);

<span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">update_back</span>(<span style="color: #35CDAF;">heap_seg</span>*, <span style="color: #35CDAF;">heap_seg</span>*, <span style="color: #35CDAF;">bool</span>);

<span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">heap_init</span>(<span style="color: #35CDAF;">size_t</span>);
<span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">malloc</span>(<span style="color: #35CDAF;">size_t</span>);
<span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">free</span>(<span style="color: #35CDAF;">void</span>*);
<span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">calloc</span>(<span style="color: #35CDAF;">size_t</span>, <span style="color: #35CDAF;">size_t</span>);
<span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">realloc</span>(<span style="color: #35CDAF;">void</span>*, <span style="color: #35CDAF;">size_t</span>);

<span style="color: #85DDFF; font-weight: bold;">#endif</span> <span style="color: #579C4C;">// </span><span style="color: #579C4C;">GALLOCC_H_</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org8df1f99" class="outline-2">
<h2 id="org8df1f99"><span class="underline">Exploration</span></h2>
<div class="outline-text-2" id="text-org8df1f99">
<p>
You have hopefully heard a concept in programming called the &ldquo;heap&rdquo;. Each time we dynamically allocate memory in our program it ends up on the heap. We know that the computer has all the memory available, so it must have given some of this memory to our heap. For now let&rsquo;s just imagine that asking for this memory in our program is super complicated, so we will use a statically allocated buffer that we manage ourselves.
</p>

<p>
Let&rsquo;s start off by laying our groundwork for this exploration.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#define</span> <span style="color: #85DDFF;">HEAP_SIZE</span> <span style="color: #B5CEA8; font-weight: bold;">1024</span>

<span style="color: #35CDAF;">void</span>* <span style="color: #85DDFF;">heap_base</span>;

<span style="color: #339CDB;">typedef</span> <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> {
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>;
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span>;
} <span style="color: #35CDAF;">heap_seg</span>;
</pre>
</div>

<p>
For now, we will set our heap to a fixed size of <code>1024</code> bytes, and we will use a global variable (☢ I know, I know ☢) to keep track of the base of our heap. Then we define a struct for each segment of our heap, which for now holds a <code>size_t</code> to hold the size in bytes, and a pointer for the previous segment. We will later see how we can perform some cleaver transformations on our size to store more information.
</p>
</div>
<div id="outline-container-org7aed1d5" class="outline-3">
<h3 id="org7aed1d5"><span class="underline">Initialization</span></h3>
<div class="outline-text-3" id="text-org7aed1d5">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">heap_init</span>(<span style="color: #35CDAF;">void</span>* <span style="color: #85DDFF;">base</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>base) { <span style="color: #339CDB;">return</span> -<span style="color: #B5CEA8; font-weight: bold;">1</span>; }
  heap_base = base;
  *(<span style="color: #35CDAF;">heap_seg</span>*)heap_base = (heap_seg){HEAP_INC, <span style="color: #339CDB;">NULL</span>};
  <span style="color: #339CDB;">return</span> <span style="color: #B5CEA8; font-weight: bold;">0</span>;
}

</pre>
</div>

<p>
From there we need to set our heap up so that users can begin to use it. In a real heap implementation this would be included in the first call to <code>malloc</code>, but with our static version this won&rsquo;t be possible. Our only real setup here is to initialize our first heap segment, which will occupy the entire space by itself. We want to keep heap segments as large as possible so that we have a higher likelihood of being able to fit a requested allocation.
</p>

<p>
Once our heap is ready to go we can begin handing out pointers to different segments. Sounds easy right?
</p>
</div>
</div>
<div id="outline-container-org8a9ab10" class="outline-3">
<h3 id="org8a9ab10"><span class="underline">Allocation</span></h3>
<div class="outline-text-3" id="text-org8a9ab10">
<p>
We will leave error handling out for right now to focus in on the core logic.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">heap_malloc</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">ptr</span> = heap_base;
  <span style="color: #339CDB;">while</span> (ptr &lt; (<span style="color: #35CDAF;">heap_seg</span>*)(heap_base + HEAP_SIZE)) {
    <span style="color: #339CDB;">if</span> ((ptr-&gt;size &amp; <span style="color: #B5CEA8; font-weight: bold;">0x1</span>) == <span style="color: #B5CEA8; font-weight: bold;">0</span> &amp;&amp; ptr-&gt;size &gt;= bytes + <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
      <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Store old capacity</span>
      <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_cap</span> = ptr-&gt;size;
      <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Heap segment is free, and big enough</span>
      ptr-&gt;size = <span style="color: #339CDB;">sizeof</span>(heap_seg) +
                      ((bytes + (<span style="color: #339CDB;">sizeof</span>(heap_seg) - <span style="color: #B5CEA8; font-weight: bold;">1</span>)) / <span style="color: #339CDB;">sizeof</span>(heap_seg)) *
                          <span style="color: #339CDB;">sizeof</span>(heap_seg) |
                  <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;
      <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">user_block</span> = (<span style="color: #35CDAF;">void</span> *)(ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>);
      <span style="color: #339CDB;">if</span> (old_cap &gt; ptr-&gt;size) {
        <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = ptr + ptr-&gt;size / <span style="color: #339CDB;">sizeof</span>(heap_seg);
        next_block-&gt;size = old_cap - (ptr-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
      }
      <span style="color: #339CDB;">return</span> user_block;
    }
    prev = ptr;
    ptr = (<span style="color: #35CDAF;">void</span>*)ptr / (ptr-&gt;size &amp; (~<span style="color: #B5CEA8; font-weight: bold;">1</span>));
  }

  <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
}
</pre>
</div>

<p>
Yeah, it&rsquo;s a bit more going on that I would have assumed at first, but it won&rsquo;t be too hard to step through. Also note that we are currently covering what is called <i>first fit</i> right now, where we find the first chunk able to fulfil the allocation request, we will cover a different allocation strategy later.
</p>

<p>
We first start at the base of our heap, and begin checking at each spot if it is both free, and large enough to handle the requested allocation. Once a chunk if found we note its original capacity, and change it&rsquo;s size to hold the requested amount of bytes. This is also where we set its previous element. You may notice that we don&rsquo;t set the size to be equal to <code>bytes</code> as the user requested, instead we have to factor in a few more things.
</p>

<p>
The first portion of the size is the <code>heap_seg</code> struct itself, which in the current implementation is 16 bytes. The next section is the data, which needs to be aligned on 8 byte boundaries. We do this for efficient memory access, as a word on modern 64-bit systems is 8 bytes. To accomplish this we round up the requested size to the nearest multiple of 8, so 16 bytes stays at 16, and 17 bytes rounds up to 24.
</p>

<p>
Once we put this all together we set the least significant bit to 1. This final bit allows us to keep track of if the heap segment is in use. We are able to do this because each size will be a multiple of 8, meaning that its lower 3 bits will always be 0. We are currently using 1 of the 3 bits, so we can potentially even store more flags if needed.
</p>

<p>
There we go, we have now produced a heap segment that can be returned to the user. We note the position where they are allowed to begin writing, which we will return at the end of our function. The last step is to see if we need to segment the heap. If the section we allocated is less than the old capacity we get a pointer to the start of the next heap segment, and then set its size to the remaining space in the heap.
</p>


<div id="org0ace421" class="figure">
<p><img src="heap_segmenting.png" alt="heap_segmenting.png" />
</p>
</div>

<p>
That&rsquo;s how we hand out segments of our heap to users! If we don&rsquo;t find a suitable segment we advance to the next segment and start over again.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #35CDAF;">uint8_t</span> <span style="color: #85DDFF;">heap</span>[HEAP_SIZE];
  heap_init(heap);

  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">block</span> = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  assert(block != <span style="color: #339CDB;">NULL</span>);
  *block = <span style="color: #B5CEA8; font-weight: bold;">4</span>;

  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">num</span> = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  assert(num != <span style="color: #339CDB;">NULL</span>);
  *num = <span style="color: #B5CEA8; font-weight: bold;">7</span>;

  printf(<span style="color: #DB8E73;">"Num holds: %d\n"</span>, *num);
  printf(<span style="color: #DB8E73;">"Block holds: %d\n"</span>, *block);
}
</pre>
</div>

<pre class="example" id="org36ed229">
Num holds: 7
Block holds: 4
</pre>

<p>
It was fairly easy to hand out memory, so how does the user give that memory back?
</p>
</div>
</div>
<div id="outline-container-org99e73b3" class="outline-3">
<h3 id="org99e73b3"><span class="underline">Freeing</span></h3>
<div class="outline-text-3" id="text-org99e73b3">
<p>
In our most basic implementation &ldquo;freeing&rdquo; memory will be nothing more than setting its least significant bit back to 0.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">heap_free</span>(<span style="color: #35CDAF;">void</span>* <span style="color: #85DDFF;">block</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>block) { <span style="color: #339CDB;">return</span>; }
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">header</span> = (<span style="color: #35CDAF;">heap_seg</span>*)block - <span style="color: #B5CEA8; font-weight: bold;">1</span>;
  header-&gt;size ^= <span style="color: #B5CEA8; font-weight: bold;">1</span>;
}
</pre>
</div>

<p>
But we may run into a bit of a problem here. What happens if a user allocated a many 8 byte segments at the start of their program, and then frees them all back once their program gets under way. Then they need to allocate larger segments of memory. With our current free function we would have to skip over all of these tiny segments till we found one large chunk to hand back to the user. What if all of those small segments added together would have been enough to handle their allocation.
</p>

<p>
This is where we have to rejoin our heap segments to ensure that we do not &ldquo;fragment&rdquo; the heap. Surprisingly this is also fairly easy to accomplish once you can visualize the possible states our heap may be in.
</p>

<p>
When a user requests to free a block there are only 3 possible states that it may be in.
</p>


<div id="org93cb4e7" class="figure">
<p><img src="freeing_patterns.png" alt="freeing_patterns.png" />
</p>
</div>
<ol class="org-ol">
<li>The segment above or below is free, in which case we need to combine our segment with the adjacent free segment.</li>
<li>Both segments above and below are free, in which case we need to combine all 3 into a larger block.</li>
<li>The segments above and below are still in use, in which case we simply set the LSB to 0.</li>
</ol>

<p>
If we follow this behavior on every free call we ensure that every block in our heap will fall into 1 of these 3 states. The implementation here is just to check the block above and below the current block, then apply any needed transformations.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">heap_free</span>(<span style="color: #35CDAF;">void</span>* <span style="color: #85DDFF;">block</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>block) { <span style="color: #339CDB;">return</span>; }
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">header</span> = (<span style="color: #35CDAF;">heap_seg</span>*)block - <span style="color: #B5CEA8; font-weight: bold;">1</span>;
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Get prev/next pointers</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = header-&gt;prev;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next</span> = (<span style="color: #35CDAF;">void</span>*)header + (header-&gt;size &amp; (~<span style="color: #B5CEA8; font-weight: bold;">1</span>));
  <span style="color: #339CDB;">if</span> (prev &gt; (<span style="color: #35CDAF;">heap_seg</span>*)heap_base &amp;&amp; <span style="color: #85DDFF; font-weight: bold;">!</span>(prev-&gt;size &amp; <span style="color: #B5CEA8; font-weight: bold;">1</span>)) {
    prev-&gt;size += header-&gt;size;
    header = prev;
  }
  <span style="color: #339CDB;">if</span> (next &lt; heap_base + HEAP_SIZE &amp;&amp; <span style="color: #85DDFF; font-weight: bold;">!</span>(next-&gt;size &amp; <span style="color: #B5CEA8; font-weight: bold;">1</span>)) {
    header-&gt;size += next-&gt;size;
  }

  header-&gt;size ^= <span style="color: #B5CEA8; font-weight: bold;">1</span>;
}
</pre>
</div>

<p>
Expanding on the previous function we obtain pointers to the blocks directly before and after the current block. Then we can check each block, and see if it needs to be merged. If the previous block is free we update it&rsquo;s size to include the current block, and update our <code>header</code> pointer to this previous block. Then the next block is checked, and we update our size accordingly. The last step is to zero out the &ldquo;in use&rdquo; bit of our header.
</p>

<p>
Note that we do not need to explicitly do anything with the freed memory. By updating the size of the surrounding nodes, we ensure that it will be skipped over when searching for the closest free block. Also, by updating our <code>header</code> pointer we ensure that the following logic will work for any of the 3 possible states of our segment.
</p>

<p>
With our allocation and freeing functions complete, that is pretty much it for the most basic of heap allocators.
</p>
</div>
</div>
<div id="outline-container-orgcd1fc69" class="outline-3">
<h3 id="orgcd1fc69"><span class="underline">Example Usage</span></h3>
<div class="outline-text-3" id="text-orgcd1fc69">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #35CDAF;">uint8_t</span> <span style="color: #85DDFF;">heap</span>[HEAP_SIZE];
  heap_init(heap);

  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">block</span> = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  *block = <span style="color: #B5CEA8; font-weight: bold;">4</span>;

  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">num</span> = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  *num = <span style="color: #B5CEA8; font-weight: bold;">7</span>;

  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">test</span> = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  *test = <span style="color: #B5CEA8; font-weight: bold;">66</span>;

  printf(<span style="color: #DB8E73;">"Address of block: %p\n"</span>, block);
  printf(<span style="color: #DB8E73;">"Address of num: %p\n"</span>, num);
  printf(<span style="color: #DB8E73;">"Address of test: %p\n"</span>, test);

  printf(<span style="color: #DB8E73;">"Size of block: %d\n"</span>, ((<span style="color: #35CDAF;">heap_seg</span>*)block-<span style="color: #B5CEA8; font-weight: bold;">1</span>)-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
  printf(<span style="color: #DB8E73;">"Size of num: %d\n"</span>, ((<span style="color: #35CDAF;">heap_seg</span>*)num-<span style="color: #B5CEA8; font-weight: bold;">1</span>)-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
  printf(<span style="color: #DB8E73;">"Size of test: %d\n"</span>, ((<span style="color: #35CDAF;">heap_seg</span>*)test-<span style="color: #B5CEA8; font-weight: bold;">1</span>)-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);

  heap_free(num);
  heap_free(test);

  num = heap_malloc(<span style="color: #B5CEA8; font-weight: bold;">32</span>);
  *num = <span style="color: #B5CEA8; font-weight: bold;">1</span>;

  printf(<span style="color: #DB8E73;">"Address of block: %p\n"</span>, block);
  printf(<span style="color: #DB8E73;">"Address of num: %p\n"</span>, num);
  printf(<span style="color: #DB8E73;">"Size of block: %d\n"</span>, ((<span style="color: #35CDAF;">heap_seg</span>*)block-<span style="color: #B5CEA8; font-weight: bold;">1</span>)-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
  printf(<span style="color: #DB8E73;">"Size of num: %d\n"</span>, ((<span style="color: #35CDAF;">heap_seg</span>*)num-<span style="color: #B5CEA8; font-weight: bold;">1</span>)-&gt;size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
}
</pre>
</div>

<pre class="example" id="org82fb5db">
Address of block: 0x7ffcef5b94a8  &lt;-- Heap Base
Address of num: 0x7ffcef5b94b8    &lt;-- Heap Base + 16
Address of test: 0x7ffcef5b94c8   &lt;-- Heap Base + 32

Size of block: 16
Size of num: 16
Size of test: 16

Address of block: 0x7ffcef5b94a8  &lt;-- Heap Base
Address of num: 0x7ffcef5b94b8    &lt;-- Heap Base + 16 (same address as above)

Size of block: 16
Size of num: 40   &lt;-- 32 byte allocation + 8 byte header
</pre>
</div>
</div>
<div id="outline-container-org68d65a8" class="outline-3">
<h3 id="org68d65a8"><span class="underline">Takeaways</span></h3>
<div class="outline-text-3" id="text-org68d65a8">
<p>
Implementing a naive memory allocator is fairly easy. It won&rsquo;t be the fastest one in the world, nor the most secure. Either way, this small exploration shows us the basics of how we can hand out chunks of memory to a user, and allow them to be freed back to us.
</p>

<p>
The <i>first fit</i> algorithm that we chose to implement above is one of the quicker ways to allocate memory (we can also add a global variable that points to the first free block, to further increase speed). While speed is an important factor when it comes to allocating memory, sometimes the user might wish to be more space efficient as opposed to time efficient.
</p>


<div id="orgac8033f" class="figure">
<p><img src="first_fit.png" alt="first_fit.png" />
</p>
</div>

<p>
Instead of finding the first available spot we can find the <i>best fit</i> segment which is the smallest segment large enough to handle the requested allocation. One of the major advantages of this algorithm is that it avoids splitting large heap segments, which we should try to preserve for large allocations.
</p>


<div id="org68bcc47" class="figure">
<p><img src="best_fit.png" alt="best_fit.png" />
</p>
</div>

<p>
The biggest problem with splitting large heap segments is that we fragment our heap. Our next large allocation may not be able to find a contiguous segment to hold it, thus requiring our allocator to go out to the operating system and request more memory. For this reason, our next iteration will explore this algorithm.
</p>

<p>
We will see these functions used in the next section, but I will introduce them now so that you can become familiar with their behavior.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">size_t</span> <span style="color: #D9DAA2;">round_bytes</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
  <span style="color: #339CDB;">return</span> (bytes + (<span style="color: #339CDB;">sizeof</span>(<span style="color: #35CDAF;">void</span> *) - <span style="color: #B5CEA8; font-weight: bold;">1</span>)) / <span style="color: #339CDB;">sizeof</span>(<span style="color: #35CDAF;">void</span> *) * <span style="color: #339CDB;">sizeof</span>(<span style="color: #35CDAF;">void</span> *);
}

<span style="color: #35CDAF;">bool</span> <span style="color: #D9DAA2;">segment_free</span>(<span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">seg</span>) { <span style="color: #339CDB;">return</span> <span style="color: #85DDFF; font-weight: bold;">!</span>(seg-&gt;size &amp; <span style="color: #B5CEA8; font-weight: bold;">0x1</span>); }

<span style="color: #35CDAF;">size_t</span> <span style="color: #D9DAA2;">segment_size</span>(<span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">seg</span>) { <span style="color: #339CDB;">return</span> seg-&gt;size &amp; (~<span style="color: #B5CEA8; font-weight: bold;">1</span>); }
</pre>
</div>

<p>
Our first new function will perform the byte rounding aligning us to the nearest block of 8 bytes. The next function checks if a block is free, and finally we have a function to get the true size of a block.
</p>

<p>
Our current implementation also relies on a statically allocated buffer, meaning once we fill this up we won&rsquo;t be able to hand out more memory. Let&rsquo;s see how we can make this behavior more dynamic by requested more memory from the operating system.
</p>
</div>
</div>
</div>
<div id="outline-container-orgeeed2c5" class="outline-2">
<h2 id="orgeeed2c5"><span class="underline">sbrk()</span></h2>
<div class="outline-text-2" id="text-orgeeed2c5">
<p>
While the exact details of how a program is laid out in memory is not required to understand this portion, it will be very helpful.
</p>

<p>
Any of the programs that you choose run on your computer are running in <a href="https://en.wikipedia.org/wiki/User_space_and_kernel_space"><i>user-space</i></a>. The CPU scheduling that an operating system does won&rsquo;t apply here, as we are more concerned with the memory layout of our program. Essentially, when our program is running the operating system provides it a virtual memory space, which our program sees as one contiguous memory space that it has control over.
</p>

<p>
A program like Firefox or OBS does not need to be concerned with the other programs running on the computer. Under the hood each program may be spread out all over physical memory, or intertwined together with other programs. For our <i>user-space</i> programs to work the operating system &ldquo;lies&rdquo; to them, providing a single contiguous section of memory. Our program then runs as if it is the only program on the computer.
</p>

<p>
When are program is run, it is loaded into memory with a layout as depicted below.
</p>


<div id="org5e63367" class="figure">
<p><img src="memory_layout.png" alt="memory_layout.png" />
</p>
</div>

<p>
The stack holds local variables and any other data in which it&rsquo;s size is known at run time. On certain architectures the stack may also be used to hold function arguments. Program Data/Code holds things like constants, uninitialized variables, and the code itself. Lastly, the heap is our program&rsquo;s dynamic memory space, which can hold variables whos size or quantity is unknown at compile time.
</p>

<p>
The amount of stack space a program has is set on a operating system level on linux. Running <code>ulimit -a</code> will show all the current limits for your user. On my machine stack size is set to <code>8192 kb</code> or <code>~8 mb</code>. A program uses more of the stack by subtracting a certain number of bytes from the <a href="https://en.wikipedia.org/wiki/Stack_register"><i>stack pointer</i></a>, making sure to keep this aligned to the architecture specific value.
</p>

<p>
On the other hand, the heap is not something the user has direct control over from their assembly. In order to get more memory for our heap we have to ask the operating system.
</p>

<p>
I have been referring to our memory allocator as a &ldquo;heap allocator&rdquo;, where the heap refers to the &ldquo;heap&rdquo; in memory. Just like our buffer of <code>1024</code> bytes in our original implementation, the heap is a large contiguous section of memory. Yet unlike our <code>1024</code> byte buffer the heap can grow and shrink as needed. This is accomplished with the system call <code>sbrk()</code>.
</p>

<pre class="example" id="org9bc1e45">
It is worth noting that modern implementations of malloc() use mmap instead of calls to sbrk. There are many reasons why this change was made, but it essentially boils down to the fact that mmap fits our use cases better, and is safer to use.

Using sbrk directly in our code is part of the Posix system API. The Posix API allows our programs to be run on any Posix compliant system, meaning it is essentially an operating system abstraction layer. sbrk (and brk) have both been deprecated in the Posix API.

Our implementation will still explore sbrk as it's way to gain more memory.
</pre>

<p>
So how does <code>sbrk</code> work?
</p>

<p>
<code>sbrk</code> allows a user to specify the number of bytes by which the heap should grow. This is controlling the <i>program break</i>, which is the address directly beyond the data segment of our program. <code>sbrk</code> has 2 use cases, incrementing the <i>program break</i>, or when called with <code>0</code>, returning the address of the <i>program break</i>. Let&rsquo;s take a look at how these work.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;unistd.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdio.h&gt;</span>
<span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">brk</span> = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
  sbrk(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  <span style="color: #35CDAF;">void</span>* <span style="color: #85DDFF;">new_brk</span> = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);

  printf(<span style="color: #DB8E73;">"Program-Break:  %p\n"</span>, brk);
  printf(<span style="color: #DB8E73;">"Program-Break:  %p\n"</span>, new_brk);

  printf(<span style="color: #DB8E73;">"Distance-Between: %d\n"</span>, new_brk - brk);
}
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">Program-Break:</td>
<td class="org-right">0x55c6fef9c000</td>
</tr>

<tr>
<td class="org-left">Program-Break:</td>
<td class="org-right">0x55c6fef9c004</td>
</tr>

<tr>
<td class="org-left">Distance-Between:</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>

<p>
The first call to <code>sbrk</code> returns the <i>heap base</i>, equivalent to the starting address of our 1024 byte buffer. We then increase the program break by 4 bytes, which returns the address of the <b>previous</b> program break. Therefore, we have to call <code>sbrk(0)</code> again to get the new program break. We see that the distance between the 2 pointers is exactly 4 bytes, exactly what we requested.
</p>

<pre class="example" id="org9643d84">
The reason why we have to call printf after acquiring the memory address is that it allocates memory internally.
</pre>

<p>
This is great! We can now increase the programs heap segment whenever we want. Let&rsquo;s take a look at how we can implement this in our <code>malloc</code> function.
</p>
</div>
<div id="outline-container-org1d19f80" class="outline-3">
<h3 id="org1d19f80"><span class="underline">Adding sbrk()</span></h3>
<div class="outline-text-3" id="text-org1d19f80">
<p>
Now that we will be using <code>sbrk</code> directly in our program we are going to start running into a problem. The <code>malloc</code> implementation on our machine will be calling <code>sbrk</code> or <code>mmap</code> to increase its heap, and we will be trying to do the same. The issue is that our heaps are intertwined. If my <code>malloc</code> and the system&rsquo;s <code>malloc</code> are both being run they will step on each other&rsquo;s toes.
</p>

<p>
We can get around this by &ldquo;overriding&rdquo; <code>malloc</code> for our program.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdint.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdio.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdlib.h&gt;</span>
<span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">malloc</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>) {
  exit(<span style="color: #B5CEA8; font-weight: bold;">72</span>);
}

<span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">memory</span> = malloc(<span style="color: #B5CEA8; font-weight: bold;">400</span>);
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-sh">jackson@jtop:/tmp$ gcc test.c &amp;&amp; ./a.out
jackson@jtop:/tmp$ <span style="color: #35CDAF;">echo</span> $<span style="color: #85DDFF;">?</span>
<span style="color: #B5CEA8; font-weight: bold;">72</span>
</pre>
</div>

<p>
Our custom malloc implementation simply exits the program with a code of <code>72</code>. Of course, this isn&rsquo;t very useful, but it demonstrates that we can override the <code>malloc</code> functionality. The first portion of our malloc function will remain the same, initializing our heap, and handing out the first segment. For our static memory allocator we had to call an initialization function in main, but we will have to encode that behavior directly in <code>malloc</code> now.
</p>
</div>
<div id="outline-container-org225d3dc" class="outline-4">
<h4 id="org225d3dc">Heap Initialization</h4>
<div class="outline-text-4" id="text-org225d3dc">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">heap_init</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
    heap_base = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">increment</span> =
        (bytes &gt; HEAP_INC) ? <span style="color: #339CDB;">sizeof</span>(heap_seg) + round_bytes(bytes) : HEAP_INC;
    sbrk(increment);
    *heap_base = (heap_seg){increment, <span style="color: #339CDB;">NULL</span>};
    <span style="color: #339CDB;">if</span> ((<span style="color: #35CDAF;">int64_t</span>)(heap_end = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>)) == -<span style="color: #B5CEA8; font-weight: bold;">1</span>) {
      <span style="color: #339CDB;">return</span> -<span style="color: #B5CEA8; font-weight: bold;">1</span>;
    }
    <span style="color: #339CDB;">return</span> <span style="color: #B5CEA8; font-weight: bold;">0</span>;
}
</pre>
</div>

<p>
Our first step is to set up our base pointer, then we check to see how many bytes need to be allocated. We have discussed this before, but it boils down to rounding our size to the closest multiple of 8 that can hold the allocation. Lastly we check if the allocation was successful, and return based on that.
</p>
</div>
</div>
<div id="outline-container-org9cfbf50" class="outline-4">
<h4 id="org9cfbf50"><code>malloc()</code> with <code>sbrk()</code></h4>
<div class="outline-text-4" id="text-org9cfbf50">
<p>
From there we scan through our heap one node at a time until we find a suitable spot. Same as before, updating links in our list as we move along.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">malloc</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>heap_base) {
    heap_init(bytes);
  }
  <span style="color: #339CDB;">if</span> (bytes == <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
  }

  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Start from heap base, find first open segment that can hold 'bytes'</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">ptr</span> = heap_base;
  <span style="color: #339CDB;">while</span> (ptr &lt; (<span style="color: #35CDAF;">heap_seg</span> *)heap_end) {
    <span style="color: #339CDB;">if</span> (segment_free(ptr) &amp;&amp; ptr-&gt;size &gt;= bytes + <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
      <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Store old capacity</span>
      <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_cap</span> = ptr-&gt;size;
      <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Heap segment is free, and big enough</span>
      ptr-&gt;size = <span style="color: #339CDB;">sizeof</span>(heap_seg) + round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;
      ptr-&gt;prev = prev;
      <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">user_block</span> = ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
      <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span> = old_cap - segment_size(ptr);
      <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
        ptr-&gt;size += next_size;
      } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (old_cap &gt; ptr-&gt;size) {
        <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
        next_block-&gt;size = old_cap - segment_size(ptr);
        next_block-&gt;prev = ptr;
      }
      <span style="color: #339CDB;">return</span> user_block;
    }
    prev = ptr;
    ptr = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">.... continued below</span>
</pre>
</div>

<p>
This shouldn&rsquo;t be any different from what we saw before, except for extracting some behavior out into separate functions. Our next step is where we introduce new behavior. If we reach the end of our heap and have not found a suitable spot our heap needs to expand. The first step will be determining how many bytes we need to increase our heap by, the same decision we made when initializing our heap. From there it will go much the same.
</p>

<div class="org-src-container">
<pre class="src src-C">  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">.... continued from above</span>
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span>;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">increment</span> = (bytes &gt; HEAP_INC) ? round_bytes(bytes) : HEAP_INC;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">new_size</span> = round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;

  <span style="color: #D9DAA2;">sbrk</span>(increment + <span style="color: #339CDB;">sizeof</span>(heap_seg));
  ptr-&gt;size = new_size + <span style="color: #339CDB;">sizeof</span>(heap_seg);
  ptr-&gt;prev = prev;
  next_size = increment - segment_size(ptr);
  heap_end = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Check if the next segment should be initialized</span>
  <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
    ptr-&gt;size += next_size;
  } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (next_size &gt; <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
    next_block-&gt;size = next_size;
    next_block-&gt;prev = ptr;
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Return user writable address</span>
  <span style="color: #339CDB;">return</span> ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
}
</pre>
</div>

<p>
We will go over how we can visualize our heap in just a moment, for now let&rsquo;s go through the code. After we have determined how many bytes are needed, the pointers are updated, and the <code>heap_end</code> pointer is moved. Our last step is to check if the segment following our allocation should be initialized. This is to avoid allocating a space that would be too small to hold any data. If we have a space that is too small we can just include it in the previous segment, otherwise it becomes its own segment.
</p>

<p>
Before we see this code in action let&rsquo;s look at how we can visualize our heap.
</p>
</div>
</div>
<div id="outline-container-orgb54f01b" class="outline-4">
<h4 id="orgb54f01b">Observing Behavior</h4>
<div class="outline-text-4" id="text-orgb54f01b">
<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">heap_walk</span>() {
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">ptr</span> = heap_base;
  <span style="color: #339CDB;">while</span> (ptr &lt; (<span style="color: #35CDAF;">heap_seg</span> *)heap_end) {
    printf(<span style="color: #DB8E73;">"Segment size: %4ld, Prev: %14p, Value: %ld, Address: %p\n"</span>,
           ptr-&gt;size, ptr-&gt;prev, (ptr-&gt;size &amp; <span style="color: #B5CEA8; font-weight: bold;">1</span>) ? *(<span style="color: #35CDAF;">uint64_t</span> *)(ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>) : -<span style="color: #B5CEA8; font-weight: bold;">1</span>,
           ptr);
    ptr = (<span style="color: #35CDAF;">void</span> *)ptr + (ptr-&gt;size &amp; (~<span style="color: #B5CEA8; font-weight: bold;">1</span>));
  }
}
</pre>
</div>

<p>
We see the same logic that we use to find the next block as we saw in malloc. Each segment is printed out as a <code>uint64_t</code> for now, although this isn&rsquo;t the most flexible as we will see. Even if this is basic it will help us solve many bugs, and to iron out implementation details.
</p>

<p>
Now we can see how our newly upgraded <code>malloc</code> works!
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #35CDAF;">int</span> *<span style="color: #85DDFF;">block</span> = malloc(<span style="color: #B5CEA8; font-weight: bold;">4</span>);
  *block = <span style="color: #B5CEA8; font-weight: bold;">4</span>;

  <span style="color: #35CDAF;">uint64_t</span> *<span style="color: #85DDFF;">num</span> = malloc(<span style="color: #B5CEA8; font-weight: bold;">8</span>);
  *num = <span style="color: #B5CEA8; font-weight: bold;">7</span>;

  <span style="color: #35CDAF;">uint64_t</span> *<span style="color: #85DDFF;">test</span> = malloc(<span style="color: #B5CEA8; font-weight: bold;">69</span>);
  *test = <span style="color: #B5CEA8; font-weight: bold;">66</span>;

  <span style="color: #35CDAF;">uint64_t</span> *<span style="color: #85DDFF;">big_num</span> = malloc(<span style="color: #B5CEA8; font-weight: bold;">64</span>);
  *big_num = <span style="color: #B5CEA8; font-weight: bold;">64</span>;

  <span style="color: #35CDAF;">char</span> *<span style="color: #85DDFF;">buf</span>;
  asprintf(&amp;buf, <span style="color: #DB8E73;">"big num has the value: %ld\n"</span>, *big_num);
  puts(buf);

  heap_walk();
  <span style="color: #339CDB;">return</span> <span style="color: #B5CEA8; font-weight: bold;">0</span>;
}
</pre>
</div>

<div class="org-src-container">
<pre class="src src-v"><span style="color: #85DDFF;">big</span> <span style="color: #85DDFF;">num</span> <span style="color: #85DDFF;">has</span> <span style="color: #85DDFF;">the</span> <span style="color: #85DDFF;">value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">64</span>

<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">57</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span>          <span style="color: #579C4C;">(</span><span style="color: #85DDFF;">nil</span><span style="color: #579C4C;">),</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99000</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">57</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99038</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">57</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99038</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99070</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99070</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">4</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990a8</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990a8</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990c0</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">89</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990c0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">66</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990d8</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">81</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e990d8</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">64</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99130</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">49</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99130</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">2336652897525655906</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99180</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">592</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99180</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e991b0</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">1041</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e991b0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">2338615488418374995</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55d231e99400</span>
</pre>
</div>

<p>
Woah! This is a lot going on, and way more allocations that we performed ourselves. What happened?
</p>

<p>
Well, now that we have overwritten the glibc <code>malloc</code> implementation, all the library functions that call malloc are calling our version! This is a great sign, and will be a much better test of our functionality than we will probably end up writing. Let&rsquo;s break down each of the allocations and see how we may want to tweak some of the behavior.
</p>

<ol class="org-ol">
<li>The first 3 allocations are coming from a system library that makes 3 40 byte allocations on program startup, don&rsquo;t worry about those.</li>
<li>The next block of 4 allocations comes from <code>main</code>, where we call <code>malloc</code> 4 times.</li>
<li>The next 48 byte allocation is coming from <a href="https://linux.die.net/man/3/asprintf"><code>asprintf()</code></a>. If you&rsquo;re not familiar with this function I think of it as a bit of a cheat code for strings in C. The function will allocate a buffer to hold the entire string it generates, and gives you the pointer to that string, which you are responsible to free.</li>
<li>The chunk of 592 bytes is a result of the final allocation being larger than the available space. If you total up all the sizes of everything but the last element you will get 1024, and that final allocation is larger than 1024, therefore it forces us to add more space.</li>
<li>Finally, the 1040 byte allocation comes from <code>printf</code> allocating an internal buffer for scratch work.</li>
</ol>

<p>
You may notice something suboptimal. When <code>printf</code> requests a 1024 byte allocation we place it after the 592 byte free block. This means that if our next call to <code>malloc</code> is requesting more than 592 bytes it will be placed after the 1024 block, leaving a hole in the middle of our heap.
</p>

<p>
What if instead we move our new segment to fill that hole, leaving the empty space at the very end of our heap. That way we can avoid a large empty segment in the middle of our heap. This is beneficial for our implementation because future large allocations will now be able to make use of this space, instead of it being trapped in the middle of the heap. The changes we have to make aren&rsquo;t too bad either.
</p>
</div>
</div>
<div id="outline-container-orga765a48" class="outline-4">
<h4 id="orga765a48">Filling our Holes</h4>
<div class="outline-text-4" id="text-orga765a48">
<div class="org-src-container">
<pre class="src src-C">  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Replacing the block above</span>
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span>;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">increment</span> = (bytes &gt; HEAP_INC) ? round_bytes(bytes) : HEAP_INC;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">new_size</span> = round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;

  <span style="color: #339CDB;">if</span> (segment_free(prev)) {
    ptr = prev;
    prev = prev-&gt;prev;
    sbrk(increment);
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_size</span> = ptr-&gt;size;
    ptr-&gt;size = new_size + <span style="color: #339CDB;">sizeof</span>(heap_seg);
    next_size = (old_size + increment) - segment_size(ptr);
  } <span style="color: #339CDB;">else</span> {
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Previous chunk is not free</span>
    sbrk(increment + <span style="color: #339CDB;">sizeof</span>(heap_seg));
    ptr-&gt;size = new_size + <span style="color: #339CDB;">sizeof</span>(heap_seg);
    ptr-&gt;prev = prev;
    next_size = increment - segment_size(ptr);
  }
  heap_end = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Check if the next segment should be initialized</span>
  <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
    ptr-&gt;size += next_size;
  } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (next_size &gt; <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
    next_block-&gt;size = next_size;
    next_block-&gt;prev = ptr;
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Return user writable address</span>
  <span style="color: #339CDB;">return</span> ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">return NULL;</span>
}
</pre>
</div>

<p>
Now you can see we first check if the previous segment is free. This is easy because we have already scanned through our heap, so we know our <code>prev</code> pointer is on the last segment on our heap. If it is free we will slide up to fill it in, and then allocate the remaining needed space at the end. From there both paths follow the same steps to determine if we need to initialize the following block. Finally, we return a pointer to the user&rsquo;s block just like before.
</p>

<p>
Now we can see how our heap deals with the situation we saw before.
</p>

<div class="org-src-container">
<pre class="src src-v"><span style="color: #85DDFF;">big</span> <span style="color: #85DDFF;">num</span> <span style="color: #85DDFF;">has</span> <span style="color: #85DDFF;">the</span> <span style="color: #85DDFF;">value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">64</span>

<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span>          <span style="color: #579C4C;">(</span><span style="color: #85DDFF;">nil</span><span style="color: #579C4C;">),</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">4</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb000</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb018</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">89</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb018</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">66</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb030</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">81</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb030</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">64</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb088</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">120</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb088</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb0d8</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">49</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb0d8</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">2336652897525655906</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb150</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">1041</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb150</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span> <span style="color: #B5CEA8; font-weight: bold;">2338615488418374995</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb180</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">624</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb180</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5620c36cb590</span>
</pre>
</div>

<p>
There we go! The blank space is at the end of our heap, which will help us ensure the heap is being used efficiently.
</p>

<p>
At this point we have a fully featured memory allocator, it is not the fastest, or the most efficient, but it is correct. The most important part of a memory allocator is that it is correct, and will never hand out a memory address that is invalid.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-orga0e1742" class="outline-2">
<h2 id="orga0e1742"><span class="underline">Upgrades</span></h2>
<div class="outline-text-2" id="text-orga0e1742">
<p>
We can stop here if we really wanted to. An entire general purpose memory allocator in ~130 lines of code, but we discussed a few details of our implementation earlier that we should address now.
</p>
</div>
<div id="outline-container-org03fe733" class="outline-3">
<h3 id="org03fe733"><span class="underline">First Fit vs Best Fit</span></h3>
<div class="outline-text-3" id="text-org03fe733">
<p>
<i>first-fit</i>
<img src="first_fit.png" alt="first_fit.png" />
</p>

<p>
Just like our algorithm works, we find the first available block, and place our memory allocation there. The issue with this strategy is that we end up chunking our large blocks into smaller blocks. This leaves less large blocks, which will cause us to expand the heap next time we need to handle a large allocation request.
</p>

<p>
We should instead try to preserve as many large blocks as we can. This algorithm will run slower, because it causes us to scan the entire heap for every allocation. Of course there is always a tradeoff when it comes to programming, here we will see how trading a small amount of time for a more efficient use of space will be worth it.
</p>

<p>
<i>best-fit</i>
<img src="best_fit.png" alt="best_fit.png" />
</p>

<p>
For this algorithm to work we will have to change the way we find a segment. The linear walking of our heap can stay the same, but we will have to maintain a pointer to the smallest block large enough to hold the allocation. If we get the end and have a block, we use it to hold our allocation, otherwise we continue on like we had done before.
</p>

<p>
Our <i>first-fit</i> algorithm has a higher likelihood of segmenting the heap, and we would like to avoid this as much as possible.
</p>

<div class="org-src-container">
<pre class="src src-v"><span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">33</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span>          <span style="color: #579C4C;">(</span><span style="color: #85DDFF;">nil</span><span style="color: #579C4C;">),</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">9</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883000</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">232</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883020</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883108</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">241</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883108</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">2</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883210</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">24</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883210</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883300</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883300</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">64</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5600eb883318</span>
</pre>
</div>

<p>
If we now request a 8 byte allocation, can you see where it will be placed?
</p>

<div class="org-src-container">
<pre class="src src-v"><span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">33</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span>          <span style="color: #579C4C;">(</span><span style="color: #85DDFF;">nil</span><span style="color: #579C4C;">),</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">9</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57000</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">24</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57020</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">208</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57020</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57038</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57108</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">241</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57108</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">2</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57210</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">24</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57210</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57300</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57300</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">64</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x55a298d57318</span>
</pre>
</div>

<p>
Just like we said before, instead of finding the free 24 byte block (8 byte allocation, 16 byte header), we end up splitting the larger 232 byte block. How can we fix this in our <code>malloc()</code> function?
</p>

<div class="org-src-container">
<pre class="src src-C">  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Start from heap base, find first open segment that can hold 'bytes'</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">ptr</span> = heap_base;

  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">best_prev</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">best</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #339CDB;">while</span> (ptr &lt; (<span style="color: #35CDAF;">heap_seg</span> *)heap_end) {
    <span style="color: #339CDB;">if</span> (segment_free(ptr) &amp;&amp; ptr-&gt;size &gt;= bytes + <span style="color: #339CDB;">sizeof</span>(heap_seg) &amp;&amp;
        (<span style="color: #85DDFF; font-weight: bold;">!</span>best || segment_size(ptr) &lt; segment_size(best))) {
      best = ptr;
      best_prev = prev;
    }
    prev = ptr;
    ptr = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
  }

  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Found a suitable block for Best-Fit</span>
  <span style="color: #339CDB;">if</span> (best) {
    ptr = best;
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Store old capacity</span>
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_cap</span> = ptr-&gt;size;
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Heap segment is free, and big enough</span>
    ptr-&gt;size = <span style="color: #339CDB;">sizeof</span>(heap_seg) + round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;
    ptr-&gt;prev = prev;
    <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">user_block</span> = ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span> = old_cap - segment_size(ptr);
    <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
      ptr-&gt;size += next_size;
    } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (old_cap &gt; ptr-&gt;size) {
      <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
      next_block-&gt;size = old_cap - segment_size(ptr);
      next_block-&gt;prev = ptr;
    }
    <span style="color: #339CDB;">return</span> user_block;
  }
</pre>
</div>

<p>
This boils down to a slight refactor, with 2 new pointers, and an added condition to our searching algorithm. Instead of stopping at the first free block we check to see if it is big enough, and more importantly, the <i>best-fit</i> we have seen. After scanning through the heap we use the best block if we have one, otherwise we continue on like before.
</p>

<p>
Comparing to the series of allocations demonstrated above, this new algorithm produces a less segmented heap.
</p>

<div class="org-src-container">
<pre class="src src-v"><span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">33</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span>          <span style="color: #579C4C;">(</span><span style="color: #85DDFF;">nil</span><span style="color: #579C4C;">),</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">9</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660000</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">232</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660000</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #85DDFF; font-weight: bold;">-</span><span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660020</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660020</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660108</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">241</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660108</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                   <span style="color: #B5CEA8; font-weight: bold;">2</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660210</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">25</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660210</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">24</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660300</span>
<span style="color: #35CDAF;">Segment</span> <span style="color: #85DDFF;">size</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">265</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Prev</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660300</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>                  <span style="color: #B5CEA8; font-weight: bold;">64</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Address</span><span style="color: #579C4C;">:</span> <span style="color: #339CDB;">0x5647b2660318</span>
</pre>
</div>

<p>
Now we can see that our allocation occupies the 24 byte block near the end of the heap, leaving the entire 232 byte block for future allocation that may need more space.
</p>

<p>
That was a pretty easy change to handle, but you may notice another inefficiency. Every time an allocation is requested we have to start at the beginning of the heap. In these small examples that isn&rsquo;t an issue, but imagine a heap the is full for the first 1-2 MB, with the first free block sitting at the end. We would spend precious time scanning over blocks that we cannot use. How can we fix this?
</p>
</div>
</div>
<div id="outline-container-orgbc655d4" class="outline-3">
<h3 id="orgbc655d4"><span class="underline">Implicit vs Explicit Free Lists</span></h3>
<div class="outline-text-3" id="text-orgbc655d4">
<p>
The way our heap is linked together is what is known as an <i>implicit free list</i>, meaning that each node is directly linked together, and we use a check at each step in our list to determine if the segment is free. This works well for a simple implementation, but we are slowed down by traversing a linked list, and calling a function at each step. What if instead we only looked at the free segments.
</p>

<p>
This is known as an <i>explicit free list</i>, where the free nodes are in their own linked list. This can be implemented with either a regular linked list, or even a circularly linked list. For our best-fit strategy, a regular singly linked list makes the most sense.
</p>

<pre class="example" id="org3b16933">
We have covered first-fit and best-fit, but there is an additional allocation algorithm called next-fit. Where the searching begins from the last block that was allocated. For this algorithm we might end up starting in the middle of the list, so a circularly linked list would be required.
</pre>

<p>
Each node will now have to hold an additional pointer, adding 8 bytes of overhead. Managing these pointers will be very complicated, and can be very error-prone if we are not careful.
</p>
</div>
<div id="outline-container-orgf3fa6af" class="outline-4">
<h4 id="orgf3fa6af"><span class="underline">Groundwork</span></h4>
<div class="outline-text-4" id="text-orgf3fa6af">
<p>
The first step is adding some bookkeeping, keeping track of the first block, and adding the <code>next_free</code> pointer to our struct.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">heap_base</span> = <span style="color: #339CDB;">NULL</span>;
<span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">heap_end</span> = <span style="color: #339CDB;">NULL</span>;
<span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">first_free</span> = <span style="color: #339CDB;">NULL</span>;  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">New</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #339CDB;">typedef</span> <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> {
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>;
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span>;
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_free</span>; <span style="color: #579C4C;">// </span><span style="color: #579C4C;">New</span>
} <span style="color: #35CDAF;">heap_seg</span>;
</pre>
</div>

<p>
Then we will update our <code>free()</code> function, as this is the easiest to understand. The function remains most same, we just need to introduce one function to update our new <code>next_free</code> pointers.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">update_back</span>(<span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">cur</span>, <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">target</span>, <span style="color: #35CDAF;">bool</span> <span style="color: #85DDFF;">free_mode</span>) {
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev_free</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #339CDB;">if</span> (cur) {
    prev_free = cur-&gt;prev;
  }
  <span style="color: #339CDB;">while</span> (prev_free &amp;&amp; <span style="color: #85DDFF; font-weight: bold;">!</span>segment_free(prev_free) &amp;&amp; prev_free &gt;= heap_base) {
    prev_free = prev_free-&gt;prev;
  }

  <span style="color: #339CDB;">if</span> (prev_free) {
    <span style="color: #339CDB;">if</span> (free_mode) {
      target-&gt;next_free = prev_free-&gt;next_free;
    }
    prev_free-&gt;next_free = target;
  } <span style="color: #339CDB;">else</span> {
    <span style="color: #339CDB;">if</span> (free_mode) {
      target-&gt;next_free = first_free;
    }
    first_free = target;
  }
}

</pre>
</div>

<p>
This function takes in a current pointer, which is the location from which we will begin searching backwards. Next we take in a target pointer, and finally a boolean that tells the function which mode to use. We can use this to update our linked last so that the links between free elements remains correct.
</p>

<p>
The basic premise of how this algorithm works is fairly simple, but coming to this conclusion is difficult. It works on the principle that once a segment is in use we can simply skip over it, with the same idea working in reverse when a segment is allocated.
</p>

<p>
If we have a current node we walk it backwards until we find the previous free node. From there we do one of two things:
</p>
<ol class="org-ol">
<li>If we have a previous free node we know we are somewhere in the middle of the list. Therefore, we make this previous node point to our target. Additionally, if we are in free mode we will want to point ourselves at the next free node in the list (which is the previous nodes <code>next_free</code>).</li>
<li>Otherwise, we know that we are at the front of the list. If we&rsquo;re in free mode then we set our next to the current <code>first_free</code>, and we always make ourselves the <code>first_free</code>.</li>
</ol>

<p>
You may wonder what the <code>target</code> parameter is, and why it is necessary. This is an abstraction that allows us to use the same <code>update_back</code> function in both allocation and free calls.
</p>

<p>
When called in an allocation context our <code>target</code> is the segment immediately following our newly allocated segment. If this segment is <code>NULL</code> it will be set as the end of our linked list, otherwise it sits inside the list and pointers will be updated accordingly.
</p>

<p>
Alternatively, when called in a freeing context, <code>target</code> represents the newly freed segment. In a list of <code>[1, 2, 3]</code> our free call uses <code>1</code> as its current, and <code>2</code> as its target. An allocation call uses <code>2</code> as its current, and <code>3</code> as its target. With <code>2</code> being the element being acted upon in both cases.
</p>
</div>
</div>
<div id="outline-container-org536b740" class="outline-4">
<h4 id="org536b740"><code>free</code></h4>
<div class="outline-text-4" id="text-org536b740">
<p>
After merging adjacent segments together we need to move backwards in our last and ensure that the list now includes the current element. This is exactly the same as inserting a node in a linked list.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> <span style="color: #D9DAA2;">free</span>(<span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">block</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>block) {
    <span style="color: #339CDB;">return</span>;
  }
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">header</span> = (<span style="color: #35CDAF;">heap_seg</span> *)block - <span style="color: #B5CEA8; font-weight: bold;">1</span>;
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Get prev/next pointers</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = header-&gt;prev;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next</span> = (<span style="color: #35CDAF;">void</span> *)header + segment_size(header);
  <span style="color: #339CDB;">if</span> (prev &gt; (<span style="color: #35CDAF;">heap_seg</span> *)heap_base &amp;&amp; segment_free(prev)) {
    prev-&gt;size += header-&gt;size;
    header = prev;
  }
  <span style="color: #339CDB;">if</span> (next &lt; (<span style="color: #35CDAF;">heap_seg</span> *)heap_end &amp;&amp; segment_free(next)) {
    header-&gt;size += next-&gt;size;
    update_back(prev, header, <span style="color: #339CDB;">true</span>);
    header-&gt;next_free = next-&gt;next_free;
    header-&gt;size ^= <span style="color: #B5CEA8; font-weight: bold;">1</span>;
    <span style="color: #339CDB;">return</span>;
  }
  update_back(prev, header, <span style="color: #339CDB;">true</span>);
  header-&gt;size ^= <span style="color: #B5CEA8; font-weight: bold;">1</span>;
}
</pre>
</div>

<p>
We are essentially finding the previous free element and telling it to point at the new target, and if it doesn&rsquo;t exist then we know it is the first free segment.
</p>

<p>
Another thing to keep in mind is that if we free a block that is surrounded on both sides by in-use segments we need to jump over this block. We handle this in the <code>if next</code> block. After updating links we need to set the current blocks <code>next_free</code> pointer to jump over the in-use block.
</p>


<div id="orgc29e753" class="figure">
<p><img src="updating_back_free.png" alt="updating_back_free.png" />
</p>
</div>

<p>
When we free the 32 byte block on the heap it merges with the segment before it. Which is exactly what we want our <code>free</code> function to do, but now we have to deal with our <i>explicit free list</i>. The only change is needing to go back and point to the larger block we just made, and pointing ourselves at the next free block.
</p>
</div>
</div>
<div id="outline-container-orga28687b" class="outline-4">
<h4 id="orga28687b"><code>malloc</code></h4>
<div class="outline-text-4" id="text-orga28687b">
<p>
This is where things start to a lot more complicated in terms of <i>explicit free list</i>. One thing to keep in mind is that a linked list allows us to skip over segments currently in use. So there is no need for us to clean up <code>next_free</code> pointers each time a segment is modified. We will see how this all works in our diagrams and code.
</p>

<p>
From a basic standpoint, this is how we want <code>malloc</code> to work.
</p>


<div id="orgdc054c1" class="figure">
<p><img src="updating_back.png" alt="updating_back.png" />
</p>
</div>

<p>
Instead of pointing at our original 256 byte block, we need to traverse backwards and tell the previous free element to point at the new smaller free block. Allocating a new node and updating links is similar to how <code>free</code> works, but we will need to spend a bit more time to get our pointers in the right places, so we can use the same <code>update_back</code> function.
</p>

<p>
<code>heap_init</code> will also have to change just slightly to ensure our <code>first_free</code> pointer is set.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">heap_init</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
  heap_base = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
  first_free = heap_base;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">increment</span> =
      (bytes &gt; HEAP_INC) ? <span style="color: #339CDB;">sizeof</span>(heap_seg) + round_bytes(bytes) : HEAP_INC;
  <span style="color: #339CDB;">if</span> ((sbrk(increment)) == (<span style="color: #35CDAF;">void</span> *)-<span style="color: #B5CEA8; font-weight: bold;">1</span>) {
    <span style="color: #339CDB;">return</span> -<span style="color: #B5CEA8; font-weight: bold;">1</span>;
  }
  *heap_base = (heap_seg){increment, <span style="color: #339CDB;">NULL</span>, <span style="color: #339CDB;">NULL</span>};
  heap_end = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);
  <span style="color: #339CDB;">return</span> <span style="color: #B5CEA8; font-weight: bold;">0</span>;
}
</pre>
</div>

<p>
Let&rsquo;s start by seeing how we can now walk the linked list more efficiently.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">malloc</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">bytes</span>) {
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>heap_base) {
    heap_init(bytes);
  }
  <span style="color: #339CDB;">if</span> (bytes == <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Start from first free, find first open segment that can hold 'bytes'</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">ptr</span> = first_free;
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">best</span> = <span style="color: #339CDB;">NULL</span>;

  <span style="color: #339CDB;">while</span> (ptr &amp;&amp; ptr &lt; heap_end) {
    <span style="color: #339CDB;">if</span> (segment_free(ptr) &amp;&amp; ptr-&gt;size &gt;= bytes + <span style="color: #339CDB;">sizeof</span>(heap_seg) &amp;&amp;
        (<span style="color: #85DDFF; font-weight: bold;">!</span>best || segment_size(ptr) &lt; segment_size(best))) {
      best = ptr;
    }
    <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>ptr-&gt;next_free) {
      <span style="color: #339CDB;">break</span>;
    }
    ptr = ptr-&gt;next_free;
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Continued below ....</span>
</pre>
</div>

<p>
Now our searching loop begins at the first free element, and will skip over segments that are in use. This will reduce our searching time on a heap that has high fragmentation, or numerous in-use segments.
</p>

<p>
One consideration we have to take into mind is that we cannot walk our pointer off the end of the list. If we were to do so we would lose our pointer to the end of the list, so when we encounter this situation we break early.
</p>

<p>
We know that if we reach the end of the list without finding a <i>best-fit</i> segment we will have to expand our heap in order to accommodate the requested allocation. So it will be ok to leave <code>ptr</code> as the last element, as we will not attempt to put something in its place.
</p>

<p>
From there we follow the same 1 of 2 paths as before.
</p>

<div class="org-src-container">
<pre class="src src-C">  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">.... continued from above</span>
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Found a suitable block for Best-Fit</span>
  <span style="color: #339CDB;">if</span> (best) {
    ptr = best;
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Store old capacity</span>
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_cap</span> = ptr-&gt;size;
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Heap segment is free, and big enough</span>
    ptr-&gt;size = <span style="color: #339CDB;">sizeof</span>(heap_seg) + round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span> = old_cap - segment_size(ptr);
    <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
      ptr-&gt;size += next_size;
      update_back(best, best-&gt;next_free, <span style="color: #339CDB;">false</span>);
    } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (old_cap &gt; ptr-&gt;size) {
      <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
      *next_block =
          (heap_seg){old_cap - segment_size(ptr), ptr, ptr-&gt;next_free};
      <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_next_block</span> = (<span style="color: #35CDAF;">void</span> *)next_block + segment_size(next_block);
      <span style="color: #339CDB;">if</span> (next_next_block &lt; heap_end) {
        next_next_block-&gt;prev = next_block;
      }

      <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Scan for previous free block, update links</span>
      update_back(best, next_block, <span style="color: #339CDB;">false</span>);
    }
    <span style="color: #339CDB;">return</span> ptr + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
  }
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">continued below ....</span>
</pre>
</div>

<p>
Just as we mentioned above, if we find a suitable block we will need to point our linked list to jump around this newly allocated segment. The function accepts the allocated segment, the following block, and false denoting that we are in allocation mode.
</p>

<div class="org-src-container">
<pre class="src src-C">  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">.... continued from above</span>
  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Ran out of space</span>
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">prev</span> = <span style="color: #339CDB;">NULL</span>;
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>ptr) {
    ptr = heap_base;
    <span style="color: #339CDB;">while</span> (ptr &lt; heap_end) {
      prev = ptr;
      ptr = (<span style="color: #35CDAF;">void</span> *)ptr + segment_size(ptr);
    }
    <span style="color: #339CDB;">if</span> (ptr &lt; heap_end) {
      ptr-&gt;prev = prev;
    }
  }
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">next_size</span>;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">increment</span> = (bytes &gt; HEAP_INC) ? round_bytes(bytes) : HEAP_INC;
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">new_size</span> = round_bytes(bytes) | <span style="color: #B5CEA8; font-weight: bold;">0x1</span>;

  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">new_seg</span> = ptr;

  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">old_size</span> = (new_seg &lt; heap_end) ? new_seg-&gt;size : <span style="color: #B5CEA8; font-weight: bold;">0</span>;
  <span style="color: #339CDB;">if</span> (new_seg &lt; heap_end &amp;&amp; new_seg-&gt;prev &amp;&amp; segment_free(new_seg-&gt;prev)) {
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Previous chunk is free</span>
    new_seg = new_seg-&gt;prev;
    <span style="color: #339CDB;">if</span> ((sbrk(increment)) == (<span style="color: #35CDAF;">void</span> *)-<span style="color: #B5CEA8; font-weight: bold;">1</span>) {
      <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
    }
    new_seg-&gt;size = new_size + <span style="color: #339CDB;">sizeof</span>(heap_seg);
    next_size = (old_size + increment) - segment_size(new_seg);
  } <span style="color: #339CDB;">else</span> {
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Previous chunk is not free</span>
    <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">cur_size</span> = new_size + <span style="color: #339CDB;">sizeof</span>(heap_seg);
    <span style="color: #339CDB;">if</span> (round_bytes(bytes) &lt; increment) {
      <span style="color: #339CDB;">if</span> ((sbrk(increment)) == (<span style="color: #35CDAF;">void</span> *)-<span style="color: #B5CEA8; font-weight: bold;">1</span>) {
        <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
      }
      next_size = old_size + increment - (cur_size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>);
    } <span style="color: #339CDB;">else</span> {
      <span style="color: #339CDB;">if</span> ((sbrk(increment + <span style="color: #339CDB;">sizeof</span>(heap_seg))) == (<span style="color: #35CDAF;">void</span> *)-<span style="color: #B5CEA8; font-weight: bold;">1</span>) {
        <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
      }
      next_size =
          old_size + increment - (cur_size ^ <span style="color: #B5CEA8; font-weight: bold;">0x1</span>) + <span style="color: #339CDB;">sizeof</span>(heap_seg);
    }
    new_seg-&gt;size = cur_size;
  }
  heap_end = sbrk(<span style="color: #B5CEA8; font-weight: bold;">0</span>);

  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Check if the next segment should be initialized</span>
  <span style="color: #339CDB;">if</span> (next_size &lt;= <span style="color: #339CDB;">sizeof</span>(heap_seg)) {
    ptr-&gt;size += next_size;
  } <span style="color: #339CDB;">else</span> <span style="color: #339CDB;">if</span> (next_size &gt; <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">next_block</span> = (<span style="color: #35CDAF;">void</span> *)new_seg + segment_size(new_seg);
    *next_block = (heap_seg){next_size, new_seg, <span style="color: #339CDB;">NULL</span>};

    assert((<span style="color: #35CDAF;">void</span> *)next_block + segment_size(next_block) == heap_end);
    <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Scan for previous free block, update links</span>
    update_back(new_seg, next_block, <span style="color: #339CDB;">false</span>);
  }

  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Return user writable address</span>
  <span style="color: #339CDB;">return</span> new_seg + <span style="color: #B5CEA8; font-weight: bold;">1</span>;
}
<span style="color: #579C4C;">// </span><span style="color: #579C4C;">End</span>
</pre>
</div>

<p>
One checking is being added here, if we get to this point and our <code>first_free</code> pointer is <code>NULL</code>, we must be out of memory. This also means we don&rsquo;t have a pointer to the last element in the list, so by walking from the beginning of the list we land on the last element. This allows us to have a valid <code>prev</code> pointer, which sets us up perfectly for the remainder of the function.
</p>

<p>
The old size is also stored in a variable here, so that it can be added onto the remaining free segment after moving the heap end.
</p>

<p>
If more memory is needed, we increase our heap size, segment it, and update pointers if needed. The last step is the same as above, we find the previous free element and update our <i>explicit free list</i>.
</p>
</div>
</div>
</div>
<div id="outline-container-org9d15462" class="outline-3">
<h3 id="org9d15462"><span class="underline"><code>calloc()</code></span></h3>
<div class="outline-text-3" id="text-org9d15462">
<p>
If you remember from my previous article on <a href="hashmap.html">hashmaps</a>, I like using <code>calloc</code> during both the exploration and optimization phase of coding. Of course in performance critical applications every CPU cycle counts, but for most purposes a few extra cycles to clear out memory is more than worth it.
</p>

<p>
Surprisingly to me, implementing <code>calloc</code> is as simple as a call to malloc, <code>memset</code> to <code>0</code>, and then returning a pointer. The more interesting thing to me about <code>calloc</code> are the parameters it takes. The glibc <code>calloc</code> takes in the number of elements, and he size of each element, both being a <code>size_t</code>. This makes <code>calloc</code> easier to read in source code, and makes your intentions for the size of the allocation clearer.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">calloc</span>(<span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">count</span>, <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>) {
  <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">ptr</span> = malloc(count * size);
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>ptr) {
    <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
  }
  memset(ptr, <span style="color: #B5CEA8; font-weight: bold;">0</span>, count * size);
  <span style="color: #339CDB;">return</span> ptr;
}
</pre>
</div>

<p>
Just remember to include <code>&lt;string.h&gt;</code> for the memset function, and you should be good to go.
</p>
</div>
</div>
<div id="outline-container-orgdb2ea73" class="outline-3">
<h3 id="orgdb2ea73"><span class="underline"><code>realloc()</code></span></h3>
<div class="outline-text-3" id="text-orgdb2ea73">
<p>
I don&rsquo;t get to use <code>realloc</code> all that often, but when you find a good use case it always comes out super clean. It shouldn&rsquo;t be too hard to implement, just take a look at the behavior described in <code>man realloc</code> and you will be good to go.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #35CDAF;">void</span> *<span style="color: #D9DAA2;">realloc</span>(<span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">ptr</span>, <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">size</span>) {
  <span style="color: #35CDAF;">size_t</span> <span style="color: #85DDFF;">min</span> = (size &lt; segment_size((<span style="color: #35CDAF;">heap_seg</span> *)(ptr - <span style="color: #B5CEA8; font-weight: bold;">1</span>)))
                   ? size
                   : segment_size((<span style="color: #35CDAF;">heap_seg</span> *)(ptr - <span style="color: #B5CEA8; font-weight: bold;">1</span>)) - <span style="color: #339CDB;">sizeof</span>(heap_seg);
  free(ptr);
  <span style="color: #339CDB;">if</span> (size == <span style="color: #B5CEA8; font-weight: bold;">0</span>) {
    <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
  }
  <span style="color: #35CDAF;">heap_seg</span> *<span style="color: #85DDFF;">new_ptr</span> = malloc(size);
  <span style="color: #339CDB;">if</span> (<span style="color: #85DDFF; font-weight: bold;">!</span>new_ptr) {
    <span style="color: #339CDB;">return</span> <span style="color: #339CDB;">NULL</span>;
  }
  memmove(new_ptr, ptr, min);
  <span style="color: #339CDB;">return</span> new_ptr;
}

</pre>
</div>

<p>
The first step is to calculate how many bytes will need to be moved. We take the smallest of the 2 values, and store that for later. We can then free the original pointer, and stop here if the user requested a reallocation size of 0 (the same as a free call). A new block is allocated to hold the requested size, and we copy over the original data, finally returning the pointer to the user.
</p>
</div>
</div>
</div>
<div id="outline-container-org8670325" class="outline-2">
<h2 id="org8670325"><span class="underline">Testing</span></h2>
<div class="outline-text-2" id="text-org8670325">
<p>
We are nearly there! Time to see if we can spot any bugs while testing our code. I would recommend using standard library functions that perform allocations, using custom data structures, and performing manual allocations. Of course, it is nearly impossible to catch every possible bug, and test every edge case.
</p>
</div>
<div id="outline-container-org04894ce" class="outline-3">
<h3 id="org04894ce"><span class="underline">Hashmap Testing</span></h3>
<div class="outline-text-3" id="text-org04894ce">
<p>
For this case I am going to use the previously implemented <a href="hashmap.html">hashmap</a> for testing.
</p>

<p>
The hashmap starts out with a default size of 11, and target load factor of 0.5. I made sure to insert enough elements to ensure that it would resize at least once.
</p>
</div>
<div id="outline-container-orgb148d3f" class="outline-4">
<h4 id="orgb148d3f"><span class="underline">glibc <code>malloc</code></span></h4>
<div class="outline-text-4" id="text-orgb148d3f">
<div class="org-src-container">
<pre class="src src-v"><span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>           <span style="color: #35CDAF;">Bailey</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">92</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">2</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Dylan</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">17</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">3</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Billy</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">25</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">4</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">5</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>          <span style="color: #35CDAF;">Jackson</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">23</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">6</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">8</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">9</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">10</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>             <span style="color: #35CDAF;">Josh</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">11</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">11</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">12</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Steve</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">36</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org170e7b0" class="outline-4">
<h4 id="org170e7b0"><span class="underline">Our <code>malloc</code></span></h4>
<div class="outline-text-4" id="text-org170e7b0">
<div class="org-src-container">
<pre class="src src-v"><span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">0</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">1</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>           <span style="color: #35CDAF;">Bailey</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">92</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">2</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Dylan</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">17</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">3</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Billy</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">25</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">4</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">5</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>          <span style="color: #35CDAF;">Jackson</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">23</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">6</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">7</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">8</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>   <span style="color: #B5CEA8; font-weight: bold;">9</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">10</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>             <span style="color: #35CDAF;">Josh</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">11</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">11</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">EMPTY</span>
<span style="color: #35CDAF;">Index</span><span style="color: #579C4C;">:</span>  <span style="color: #B5CEA8; font-weight: bold;">12</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Key</span><span style="color: #579C4C;">:</span>            <span style="color: #35CDAF;">Steve</span><span style="color: #579C4C;">,</span> <span style="color: #35CDAF;">Value</span><span style="color: #579C4C;">:</span>               <span style="color: #B5CEA8; font-weight: bold;">36</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd6a3fd7" class="outline-3">
<h3 id="orgd6a3fd7"><span class="underline">Performance Testing</span></h3>
<div class="outline-text-3" id="text-orgd6a3fd7">
<p>
To test the performance of our hashmap we will perform a linear set of increase size allocations. Without freeing any of the memory allocated is essentially the worst case for our implementation. The biggest weak point of our <code>malloc</code> function is that when it runs out of memory it has to walk the entire heap before it can expand it. This set of allocations will test to see how slow this is.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdio.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;time.h&gt;</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;stdlib.h&gt;</span>         <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Swap these 2</span>
<span style="color: #579C4C;">/* </span><span style="color: #579C4C;">#include "gallocc.h"</span><span style="color: #579C4C;"> */</span>  <span style="color: #579C4C;">// </span><span style="color: #579C4C;">Swap these 2</span>

<span style="color: #35CDAF;">int</span> <span style="color: #D9DAA2;">main</span>() {
  <span style="color: #339CDB;">struct</span> <span style="color: #35CDAF;">timespec</span> <span style="color: #85DDFF;">start</span>, <span style="color: #85DDFF;">end</span>;
  clock_gettime(CLOCK_MONOTONIC, &amp;start);
  <span style="color: #35CDAF;">void</span> *<span style="color: #85DDFF;">ptr</span>;
  <span style="color: #339CDB;">for</span> (<span style="color: #35CDAF;">int</span> <span style="color: #85DDFF;">i</span> = <span style="color: #B5CEA8; font-weight: bold;">0</span>; i &lt; <span style="color: #B5CEA8; font-weight: bold;">64000</span>; i++) {
    ptr = malloc(i);
  }
  clock_gettime(CLOCK_MONOTONIC, &amp;end);

  <span style="color: #35CDAF;">double</span> <span style="color: #85DDFF;">elapsed_time</span> = (end.tv_sec - start.tv_sec) * <span style="color: #B5CEA8; font-weight: bold;">1000.0</span> +
    (end.tv_nsec - start.tv_nsec) / <span style="color: #B5CEA8; font-weight: bold;">1e6</span>;
  printf(<span style="color: #DB8E73;">"Time: %.3f milliseconds\n"</span>, elapsed_time);
}
</pre>
</div>
</div>
<div id="outline-container-org297256c" class="outline-4">
<h4 id="org297256c">glibc <code>malloc</code></h4>
<div class="outline-text-4" id="text-org297256c">
<pre class="example" id="org927bde3">
13192 System calls
67ms
</pre>
</div>
</div>
<div id="outline-container-org000a454" class="outline-4">
<h4 id="org000a454">Our <code>malloc</code></h4>
<div class="outline-text-4" id="text-org000a454">
<pre class="example" id="org1ecfbe5">
15247 System calls
1435ms
</pre>
</div>
</div>
</div>
<div id="outline-container-org3bc7419" class="outline-3">
<h3 id="org3bc7419"><span class="underline">Analysis</span></h3>
<div class="outline-text-3" id="text-org3bc7419">
<p>
Our implementation is much slower, partially explained by performing more system calls, and the walking of the list each time we run out of space. If we were to fix any bottleneck, that would be the first place to look. Another way that could be mitigated would be increased the size by which the heap increases each time.
</p>

<p>
For this speed test I used <code>strace</code> to see how much the glibc <code>malloc</code> was increasing the program break by, which turned out to be 135168 bytes. If we run our version with the original 1024 byte increment it will be much slower, so I decided to match the glibc version. Of course, this is just a trade-off of how much memory you are willing to have in-use at one time.
</p>

<p>
My goal was not to create the fastest memory allocator possible, but to use this is an opportunity to learn how they work.
</p>
</div>
</div>
</div>
<div id="outline-container-orgcc80fdf" class="outline-2">
<h2 id="orgcc80fdf"><span class="underline">Learning Moments</span></h2>
<div class="outline-text-2" id="text-orgcc80fdf">
<p>
Now that we&rsquo;ve come to the end I&rsquo;d like to talk about what I learned during the writing of this article.
</p>
</div>
<div id="outline-container-org52fe969" class="outline-3">
<h3 id="org52fe969"><span class="underline">Using gdb</span></h3>
<div class="outline-text-3" id="text-org52fe969">
<p>
I have used <code>gdb</code> from a surface level before, but never to work on complex programs like this. Most of my usage would follow the same pattern, segmentation fault, compile with <code>-g</code>, run in gdb and get a back trace. From there it was usually easy to understand what happened. That was entirely different while writing my memory allocator.
</p>

<p>
Before overwriting the glibc <code>malloc</code> it was easy to debug using print statements like I was used to. However, this came at the downside of not finding as many bugs with my code. You can only think of so many edge cases before you start running out of ideas. Once we overrode the <code>malloc</code> the bugs were instantly exposed, but this came at the downside of no longer being able to use print debugging or asserts.
</p>

<p>
Internally the printing functions and assert allocate buffers to do their scratch work, which of course wouldn&rsquo;t work if our <code>malloc</code> was failing. Time to break out <code>gdb</code> then. A small portion of the bugs could be solved by simply printing a back trace, while most others required stepping through the program. The TUI included with <code>gdb</code> made viewing source code and printing the value of different variable a lot easier.
</p>

<p>
Overall, I think this is a great style of project for learning <code>gdb</code>, with many complex operations, and the inability to use print debugging.
</p>
</div>
</div>
<div id="outline-container-org1615baa" class="outline-3">
<h3 id="org1615baa"><span class="underline">C Global State</span></h3>
<div class="outline-text-3" id="text-org1615baa">
<p>
We are often told to avoid global state when writing our programs, and I would generally agree when talking about application style programs. However, when it comes to low level or systems programming it is unavoidable in most situations.
</p>

<p>
In order for <code>malloc</code> to have as easy of a user interface as it currently does, it has to store some global state. Users expect to be able to call <code>malloc</code> and <code>free</code> anywhere in their code without having to first instantiate some sort of memory allocator object. You already know this, but <code>malloc</code> is the exact opposite of a pure function, it is entirely dependent on the state of the operating system below it, and the other processes running on the system.
</p>

<p>
Once memory has been allocated there is no easy way to get the start of the program&rsquo;s heap, so we have to store that in a variable that will be accessible to <code>malloc</code> and its related function. Similarly, there is no system call to get the first free segment in our heap, because that is a concept we created ourselves, not an operating system primitive. So we also store this in a global variable, which allowed us to implement our <i>explicit free list</i>, greatly speeding up calls to <code>malloc</code>.
</p>

<p>
The last global variable is not entirely necessary, but it helps us avoid making a system call each time we need to reference the end of our heap. Of course, we can always call <code>sbrk(0)</code> to get the end of the heap, but system calls are not free, so we try to avoid making them.
</p>
</div>
<div id="outline-container-org86ad51b" class="outline-4">
<h4 id="org86ad51b">Tradeoffs</h4>
<div class="outline-text-4" id="text-org86ad51b">
<p>
We could have avoided tracking the end of our heap by introducing another pointer to our <code>heap_seg</code> struct. Instead of just using the size of each segment to traverse the list, we could have an explicit <code>next</code> pointer. This was our last node could just point to <code>NULL</code>
</p>

<p>
This would be an optimization we could look at in the future. I avoided doing it here because our <code>heap_seg</code> struct was already 24 bytes, which I feel is a large overhead on each allocation. The glibc version of <code>malloc</code> uses headers of 16 bytes (I am probably wrong here), so for a future rewrite we might consider using one of the other 2 bits we have free at the bottom of the size to store information about being at the end of the list.
</p>

<p>
There is also the possibility of having a header and a footer, which further increases overhead, but can make the implementation much easier.
</p>
</div>
</div>
</div>
<div id="outline-container-orgf1a6068" class="outline-3">
<h3 id="orgf1a6068"><span class="underline">Linked Lists</span></h3>
<div class="outline-text-3" id="text-orgf1a6068">
<p>
I am personally not the biggest fan of linked lists, but they have their place in a library like this. Arrays are great, but they&rsquo;re entirely inflexible, both in total size, and size per element. In this case we need our implementation to be adaptable for changes in both, so a linked list is required.
</p>

<p>
In fact our writing our memory allocator is really just writing a linked list on top of a giant slab of memory. Most of the challenges we solved are the same challenges you encounter working on a linked list, complicated by the fact we want to try to increase the heap by a fixed size, as opposed to calling <code>sbrk</code> for each allocation request.
</p>

<p>
We can even solve the biggest bottleneck in our implementation by using a concept from most doubly linked lists. In addition to tracking the end of the heap we could also track the last allocated segment. Then when <code>first_free</code> is set to <code>NULL</code> the algorithm would not need to traverse the heap just to get a pointer to this last element. Each time we performed an operation on a segment we would just need to check if its address plus its size gets us past the end of the list.
</p>
</div>
</div>
<div id="outline-container-org7caa14d" class="outline-3">
<h3 id="org7caa14d"><span class="underline">Man Pages</span></h3>
<div class="outline-text-3" id="text-org7caa14d">
<p>
In addition to using a LSP like <code>clangd</code> to get function definitions and doc comments, man pages are great for learning how to use the functions available in C. <code>sbrk</code> is not the easiest function to understand, but once you read up on how it works you can start by using it in a test program. Most of the printing functions have similar names, so looking up their differences can help you choose the right one.
</p>

<p>
If you&rsquo;re unfamiliar with any system call you can look up its man page, which often includes example usage to help get you started.
</p>
</div>
</div>
<div id="outline-container-org017306a" class="outline-3">
<h3 id="org017306a"><span class="underline">Assert</span></h3>
<div class="outline-text-3" id="text-org017306a">
<p>
This is my first time using asserts throughout a program as mini test cases that need to pass to ensure the implementation is correct. Every time you discover a bug in your code add an assert to ensure that it doesn&rsquo;t happen again.
</p>

<p>
The most obvious one I can think of in our memory allocator is ensuring that the address of the last segment plus its size should equal the <code>heap_end</code> pointer. Throughout the coding of this memory allocator I ran into a nasty bug where the last segment was being left off of the heap. It turned out that when calling <code>sbrk</code> I forgot to note the size of the previous element if it was free. This size needed to be added onto the end of our list. The assert now ensures that if this happens the program will exit.
</p>

<p>
Another helpful thing with asserts is that they can easily be disabled with one like of code.
</p>

<div class="org-src-container">
<pre class="src src-C"><span style="color: #85DDFF; font-weight: bold;">#define</span> <span style="color: #85DDFF;">NDEBUG</span>
<span style="color: #85DDFF; font-weight: bold;">#include</span> <span style="color: #DB8E73;">&lt;assert.h&gt;</span>
</pre>
</div>

<p>
The <code>NDEBUG</code> line makes all assert lines a <code>nop</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-orgce27865" class="outline-2">
<h2 id="orgce27865"><span class="underline">Conclusion</span></h2>
<div class="outline-text-2" id="text-orgce27865">
<p>
That&rsquo;s it! A memory allocator in ~250 lines of code. This is definitely a project I will continue to improve upon when I get the time to do so. I find this level of programming fascinating, and it gives me a greater understanding of low level concepts.
</p>

<p>
Don&rsquo;t be afraid to reinvent the wheel, even if your wheel ends up being far from perfect. Before writing this memory allocator I had zero knowledge of how they worked, and that made me discover the pitfalls that would be skipped over if I had just looked at completed source code. <a href="https://www.youtube.com/embed/UTii4dyhR5c"><i>This video</i></a> was my introduction to the concept, and even then I strayed very far from the basics laid out in the video.
</p>

<p>
Just like with the hashmap we worked on last time, I knew how it needed to work in the end, and this guided my implementation. There were many times in writing this where I found myself avoiding a certain implementation because it felt &ldquo;wrong&rdquo;. Guess what? In the end those are the exact implementations I ended up landing on. You won&rsquo;t know if something is the &ldquo;right way&rdquo; to do it until you try.
</p>

<p>
Don&rsquo;t stop yourself from solving a problem because &ldquo;there has to be an easier/better way to do it&rdquo;. Solve the problem first, then optimize and clean up your code. The <code>update_back</code> function is a perfect example of this. I had that exact behavior in 3 different spots of the code. As soon as I saw this I tried to extract it into a function, which failed, because the behavior was not nailed down. This stalled my progress because I hated seeing the same behavior in 3 places. Duplication is bad, but extracting behavior into a function without understanding the desired behavior is worse.
</p>

<p>
So just start writing the code. You will discover the pitfalls, and then work around it. Write it once, throw it away, and write it better with what you&rsquo;ve learned.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 1/7/24</p>
<p class="author">Author: Jackson</p>
</div>
</body>
</html>